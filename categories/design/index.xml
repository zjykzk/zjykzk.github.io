<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Design on 老K随笔</title>
    <link>http://zjykzk.github.io/categories/design/</link>
    <description>Recent content in Design on 老K随笔</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>(c) 2025 zenk.</copyright>
    <lastBuildDate>Sun, 28 Jun 2020 15:44:46 +0800</lastBuildDate>
    <atom:link href="http://zjykzk.github.io/categories/design/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>《A Philosophy of Software Design》笔记</title>
      <link>http://zjykzk.github.io/posts/cs/design/aposd/</link>
      <pubDate>Sun, 28 Jun 2020 15:44:46 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/design/aposd/</guid>
      <description>&lt;h1 id=&#34;目录&#34;&gt;目录&lt;/h1&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E5%BA%A6&#34;&gt;软件复杂度&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%AE%9A%E4%B9%89&#34;&gt;定义&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E7%97%87%E7%8A%B6&#34;&gt;症状&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9%E6%94%BE%E5%A4%A7&#34;&gt;修改放大&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%AE%A4%E7%9F%A5%E8%B4%9F%E6%8B%85&#34;&gt;认知负担&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B8%8D%E7%A1%AE%E5%AE%9A%E6%98%AF%E5%90%A6%E4%BF%AE%E6%94%B9%E6%AD%A3%E7%A1%AE&#34;&gt;不确定是否修改正确&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%A0%B9%E6%BA%90&#34;&gt;根源&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%9C%AC%E8%B4%A8&#34;&gt;本质&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%96%B9%E6%B3%95&#34;&gt;方法&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%88%98%E7%95%A5%E7%BC%96%E7%A8%8B%E5%92%8C%E6%88%98%E6%9C%AF%E7%BC%96%E7%A8%8B&#34;&gt;战略编程和战术编程&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1&#34;&gt;模块化设计&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%B7%B1%E5%BA%A6%E6%A8%A1%E5%9D%97&#34;&gt;深度模块&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BF%A1%E6%81%AF%E9%9A%90%E8%97%8F&#34;&gt;信息隐藏&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E9%80%9A%E7%94%A8%E5%8C%96&#34;&gt;通用化&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%88%86%E5%B1%82&#34;&gt;分层&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B8%8B%E6%8E%A8%E5%A4%8D%E6%9D%82%E9%80%BB%E8%BE%91&#34;&gt;下推复杂逻辑&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%90%88%E5%B9%B6%E8%BF%98%E6%98%AF%E5%88%86%E5%BC%80&#34;&gt;合并还是分开？&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86&#34;&gt;错误处理&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%AE%BE%E8%AE%A1%E4%B8%A4%E6%AC%A1&#34;&gt;设计两次&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%86%99%E5%A5%BD%E6%B3%A8%E9%87%8A&#34;&gt;写好注释&lt;/a&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%9B%9E%E7%AD%94%E4%B8%8D%E5%86%99%E6%B3%A8%E9%87%8A%E7%9A%844%E4%B8%AA%E5%80%9F%E5%8F%A3&#34;&gt;回答不写注释的4个借口&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E6%80%8E%E4%B9%88%E5%86%99%E6%B3%A8%E9%87%8A%E6%B3%A8%E9%87%8A%E5%BA%94%E8%AF%A5%E8%A1%A8%E8%BE%BE%E4%BB%A3%E7%A0%81%E6%97%A0%E6%B3%95%E8%A1%A8%E8%BE%BE%E7%9A%84%E4%BF%A1%E6%81%AF&#34;&gt;怎么写注释：注释应该表达代码无法表达的信息&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%85%88%E5%86%99%E6%B3%A8%E9%87%8A&#34;&gt;先写注释&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E5%91%BD%E5%90%8D&#34;&gt;命名&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BF%AE%E6%94%B9%E8%80%81%E4%BB%A3%E7%A0%81&#34;&gt;修改老代码&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%BF%9D%E6%8C%81%E4%B8%80%E8%87%B4%E6%80%A7&#34;&gt;保持一致性&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%AE%A9%E4%BB%A3%E7%A0%81%E7%9A%84%E6%84%8F%E5%9B%BE%E6%9B%B4%E5%8A%A0%E6%98%8E%E6%98%BE&#34;&gt;让代码的意图更加明显&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%B6%8B%E5%8A%BF%E5%92%8C%E8%BD%AF%E4%BB%B6%E5%A4%8D%E6%9D%82%E5%BA%A6&#34;&gt;软件开发趋势和软件复杂度&lt;/a&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;a href=&#34;#%E4%B8%BA%E6%80%A7%E8%83%BD%E8%80%8C%E8%AE%BE%E8%AE%A1&#34;&gt;为性能而设计&lt;/a&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;《A Philosophy of Software Design》是最近读的一本关于软件设计的好书。书中定义了软件的复杂度，给出了软件复杂性的深层原因。同时，又给出了降低软件复杂度的一些建议。&lt;/p&gt;&#xA;&lt;h2 id=&#34;软件复杂度&#34;&gt;软件复杂度&lt;/h2&gt;&#xA;&lt;h3 id=&#34;定义&#34;&gt;定义&lt;/h3&gt;&#xA;&lt;p&gt;广义上来说，软件复杂度是任何和&lt;strong&gt;系统结构&lt;/strong&gt;相关的并且让系统&lt;strong&gt;难以理解和修改&lt;/strong&gt;的事情。从收益和成本角度上来看，如果实现一个简单的功能需要花费大量的精力财力，那么这个系统就是复杂的。&lt;/p&gt;&#xA;&lt;p&gt;复杂度由那些经常变动的功能来决定。因为，尽管你某个业务模块很复杂但是写完以后就不动了，那这个模块对整个系统的复杂度来说也是影响不大。反而，那些经常修改的模块，如果他们复杂度对系统整体的复杂度影响更大，因为每次修改都会影响系统复杂度。所以，在衡量一个系统复杂度是需要考虑一个修改程度这个因数。&lt;/p&gt;&#xA;&lt;p&gt;代码的阅读者是最容易发现复杂度的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;症状&#34;&gt;症状&lt;/h3&gt;&#xA;&lt;h4 id=&#34;修改放大&#34;&gt;修改放大&lt;/h4&gt;&#xA;&lt;p&gt;修改一个需求，需要改动很多地方。模块依赖，缺少抽象时，就容易发生。&lt;/p&gt;&#xA;&lt;h4 id=&#34;认知负担&#34;&gt;认知负担&lt;/h4&gt;&#xA;&lt;p&gt;修改一个功能模块，需要了解很多信息才能正确修改。比如调用c的&lt;code&gt;malloc&lt;/code&gt;函数，你得记得调用&lt;code&gt;free&lt;/code&gt;。当引用全局变量、代码结构不一致、模块依赖时，就容易出现这个问题。&lt;/p&gt;&#xA;&lt;h4 id=&#34;不确定是否修改正确&#34;&gt;不确定是否修改正确&lt;/h4&gt;&#xA;&lt;p&gt;由于代码结构复杂，除了通读这个代码才能做到正确修改功能。这种情况下面，很容易忘记某些逻辑，导致修改内容和这个逻辑产生冲突，导致bug。比如：全局变量的不一致性，某个地方认为是这样，另外一个地方却认为是另外一个意思，你不读两个地方的代码是无法发现的。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;修改放大&lt;/strong&gt;，如果告诉你具体需要修改哪些地方，那么还是能够正确实现功能的。同样，&lt;strong&gt;认知负担&lt;/strong&gt;，如果能够明确依赖哪些信息，也是能够理解代码的。&lt;strong&gt;不确定是否修改正确&lt;/strong&gt;是最糟糕的，除了通读代码全局了解以外，你是没法确定怎么修改。&lt;/p&gt;&#xA;&lt;h3 id=&#34;根源&#34;&gt;根源&lt;/h3&gt;&#xA;&lt;p&gt;复杂度的两个根源是：依赖和难懂的代码。毕竟对于信息来讲，使用它就已经形成了依赖，同时提供的信息本身也存在是否容易理解这个属性。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;依赖&lt;/strong&gt;是根本性存在的，因为我们需要做任务分解，势必存在任务之间的依赖。能够做的就是减少依赖，让依赖简单。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;难懂的代码&lt;/strong&gt;，常见的有依赖不明确，注释不充分，代码结构不一致。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;依赖&lt;/strong&gt;容易产生&lt;em&gt;修改放大&lt;/em&gt;和&lt;em&gt;认知负担&lt;/em&gt;的问题，而&lt;strong&gt;难懂的代码&lt;/strong&gt;容易产生&lt;em&gt;认知负担&lt;/em&gt;和&lt;em&gt;不确定是否修改正确&lt;/em&gt;的问题。&lt;/p&gt;&#xA;&lt;h3 id=&#34;本质&#34;&gt;本质&lt;/h3&gt;&#xA;&lt;p&gt;复杂度的本质之一是&lt;strong&gt;递增&lt;/strong&gt;的。软件只会越来越复杂，我们需要做的就是降低增加的速度。&lt;/p&gt;&#xA;&lt;h2 id=&#34;方法&#34;&gt;方法&lt;/h2&gt;&#xA;&lt;h3 id=&#34;战略编程和战术编程&#34;&gt;战略编程和战术编程&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;战术编程&lt;/strong&gt;以快速完成功能或者修复问题为目标，很难有好的设计，容易引入依赖和难懂的代码，增加系统复杂度。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;战略编程&lt;/strong&gt;强调除了完成功能和修复问题是不够，更重要的是有一个好的设计，引入当前工作不必要的复杂度。每次修改代码都需要考虑尽量使依赖最小化、依赖简单化以及代码易懂。同时，因为设计没法做到完美而存在缺陷以及需求的迭代导致当前设计过时，在修改功能的同时改进设计。&lt;/p&gt;&#xA;&lt;p&gt;显然，相比战术编程，战略编程需要花更多的时间，书中提到花开发时间的10%-20%是合理的。&lt;/p&gt;&#xA;&lt;h3 id=&#34;模块化设计&#34;&gt;模块化设计&lt;/h3&gt;&#xA;&lt;p&gt;模块化设计是管理软件复杂度的重要手段之一。通过把系统分成相对独立的字模块，&lt;strong&gt;每个模块独立处理其中一部分复杂度&lt;/strong&gt;。这里的模块是广义的概念，可以指一个服务、一个包、一个类甚至一个函数。&lt;/p&gt;&#xA;&lt;p&gt;为了管理依赖，将模块由&lt;strong&gt;接口&lt;/strong&gt;和&lt;strong&gt;实现&lt;/strong&gt;构成。接口描述模块能“做什么”，实现部分描述“怎么做”。&lt;/p&gt;&#xA;&lt;p&gt;接口包含了模块使用者需要了解的全部信息。而模块开发者需要了解接口和实现的细节。接口应该越简单越好，这样使用者需要了解的信息就越少，依赖也就越少，从而复杂度就越低。&lt;/p&gt;&#xA;&lt;p&gt;接口还细分为&lt;strong&gt;正式部分&lt;/strong&gt;和&lt;strong&gt;非正式部分&lt;/strong&gt;。正式部分是指通过代码或者协议表达出来的信息。比如函数签名，api接口中HTTP的Method等等。非正式部分是正式部分无法表达那些信息，比如接口一些副作用，某个函数调用会释放某些资源等等。通常这部分的信息要比正式部分复杂的多，只能通过注释来说明。&lt;/p&gt;&#xA;&lt;p&gt;接口的设计要让常规的场景变得简单。像JAVA中的从一个文件名创建一个有缓存的数据流需要特别的构造&lt;code&gt;BufferedInputStream&lt;/code&gt;使得缓存接口的使用变得复杂，容易遗漏这个环节。&lt;/p&gt;&#xA;&lt;p&gt;如何实现接口呢？答案是&lt;strong&gt;抽象&lt;/strong&gt;。抽象是指识别出实体的最重要部分，忽略其他不重要的信息来简化实体，抽象是很常用的工具，生活中也无处不在，像微波炉，汽车都是。&lt;/p&gt;&#xA;&lt;p&gt;模块化设计本质上就是在做抽象这件事情。它需要识别出每个字模块最重要的部分，而且尽可能的少，这样才能使得接口更加简单。如果包含了不重要的内容，增加认知负担，如果忽略的重要内容，就容易让代码难懂。&lt;/p&gt;&#xA;&lt;h4 id=&#34;深度模块&#34;&gt;深度模块&lt;/h4&gt;&#xA;&lt;p&gt;深度模块中的“深”是模块的接口简单，实现的功能强大。因为简单的接口意味着较少的依赖和容易懂，也就意味较低的复杂度。但是，提供的功能却是强大的。因此，从复杂的角度来说就是以较少的复杂度实现了较强的功能，具有高性价比。总之，越深越好。下面几小节介绍让模块变深的方法。&lt;/p&gt;</description>
    </item>
    <item>
      <title>高内聚和低耦合</title>
      <link>http://zjykzk.github.io/posts/cs/design/coupling_cohesion/</link>
      <pubDate>Fri, 12 Jun 2020 13:40:04 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/design/coupling_cohesion/</guid>
      <description>&lt;h2 id=&#34;缘起&#34;&gt;缘起&lt;/h2&gt;&#xA;&lt;p&gt;如何减少软件开发过程中维护和修改的成本？如果代码具有鲁棒性、可靠性、可读性、可复用性，那维护和修改都是比较省力气的。这就需要一些方法来实现（废话）。开发方法有很多，怎么衡量？《Composite/Structured Design》提出内聚(cohesion)和耦合(coupling)就是用来解决这个问题。&lt;/p&gt;&#xA;&lt;p&gt;高内聚和低耦合是我们最求的目标。往往高内聚意味者低耦合，反过来也是。具有这两个特征的代码能够使代码的维护和修改的成本更低。&lt;/p&gt;&#xA;&lt;h2 id=&#34;内聚&#34;&gt;内聚&lt;/h2&gt;&#xA;&lt;p&gt;什么是内聚？它是一个尺度，衡量多个不同元素属于同一个模块的合适程度。越合适越好，也就是所谓的高内聚。经常会遇到的有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一个类的方法和数据与这个类需要表达的目的是否一致。&lt;/li&gt;&#xA;&lt;li&gt;一个类的方法本身以及和数据之间的关联是否紧密。&lt;/li&gt;&#xA;&lt;li&gt;一个jar包中各个字模块的语义是不是和这个jar的语义一致。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;《Composite/Structured Design》把内聚分成了以下7类，按照顺序内聚程度一次降低。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;信息内聚(functional strength)&lt;/p&gt;&#xA;&lt;p&gt;把操作相同信息和执行单一功能的函数放在一起。比如：数据库连接池，打开连接，获取一个空闲连接，关闭一个空闲连接，缓存一个连接。这些逻辑共享一个连接池的数据结构，同时执行的逻辑都是连接池这个单一功能。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;功能内聚(information strength)&lt;/p&gt;&#xA;&lt;p&gt;执行相同单一功能的函数放在一起。一种检查方式是，把函数的语义合在一起是不是和某个具体功能一致，没有多余。比如：数据库操作需要通过数据库连接池模块拿到一个数据库连接，执行SQL，关闭数据库连接。这几个函数放在一起是一种功能内聚。封装到一个执行SQL的模块里面去。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;通信内聚(communicational strength)&lt;/p&gt;&#xA;&lt;p&gt;因为某个业务逻辑而调用多个函数放在一起。函数之间有数据依赖，一个函数的输出是另外一个函数的输入。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;过程内聚(procedural strength)&lt;/p&gt;&#xA;&lt;p&gt;同样因为某个业务逻辑而调用多个函数放在一起。但是，他们之间也没有本质关联。比如：购买某商品获得积分。就把下单、支付、添加积分放在同一个模块里面了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;空间内聚(classical strength)&lt;/p&gt;&#xA;&lt;p&gt;在一个逻辑中，有时会调用某些函数，但是这些函数之间并没有本质的关联，却把他们放在一起了。比如：转账失败的时候需要通知用户，然后就把通知用户逻辑和转账逻辑放在了一起。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;逻辑内聚(logical strength)&lt;/p&gt;&#xA;&lt;p&gt;多个函数放在一起是因为在同一个逻辑里面会被调用，即使他们本质上是不同的东西。比如，处理信号的时候把处理鼠标输入的函数和处理键盘输入的函数放在一起，然后入口函数通过识别参数来调用不同的函数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;偶然内聚(coincidental strength)&lt;/p&gt;&#xA;&lt;p&gt;函数任意的放在一起了，他们之间没有任何关系。比如常见的utils类。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;几种内聚不是天然互斥的。有时候会同时满足多种内聚，这个时候保险起见还是当作内聚性较低的那种吧。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;信息内聚&lt;/strong&gt;是最理想的情况了没有外部依赖，没有多余的逻辑，通常也是我们&lt;strong&gt;设计的类时候最需要做到的&lt;/strong&gt;。&lt;strong&gt;功能内聚&lt;/strong&gt;在一个大模块里面是常遇到的，尤其是分层架构里面，是&lt;strong&gt;需要追求&lt;/strong&gt;的一种内聚。&lt;strong&gt;通信内聚&lt;/strong&gt;、&lt;strong&gt;过程内聚&lt;/strong&gt;是也是&lt;strong&gt;可以接收&lt;/strong&gt;，&lt;strong&gt;空间内聚&lt;/strong&gt;、&lt;strong&gt;逻辑内聚&lt;/strong&gt;就得&lt;strong&gt;避免&lt;/strong&gt;了，&lt;strong&gt;偶然内聚&lt;/strong&gt;虽然在平时写代码的时候习惯使用一些utils，但是是&lt;strong&gt;可以避免&lt;/strong&gt;的，只要把相关的逻辑放到相应的模块即可。&lt;/p&gt;&#xA;&lt;h2 id=&#34;耦合&#34;&gt;耦合&lt;/h2&gt;&#xA;&lt;p&gt;什么是耦合？它也是一个尺度，衡量多个模块之间的依赖程度。依赖程度越低越好，也就是所谓的低耦合。经常会遇到的有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;一类中的方法之间联系是否紧密。&lt;/li&gt;&#xA;&lt;li&gt;一类中的方法和字段联系是否紧密。&lt;/li&gt;&#xA;&lt;li&gt;一个jar中各个模块语义是否和jar包提供的功能一致。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;《Composite/Structured Design》同样把耦合分成了以下7类，按照顺序耦合程度一次增强。他们主要体现在函数式编程范式下&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;没有直接的耦合&lt;/p&gt;&#xA;&lt;p&gt;可以作为一个基准。它是指没有其他类别的耦合。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;数据耦合(data couping)&lt;/p&gt;&#xA;&lt;p&gt;模块之间只有参数的依赖。同时，每个参数都是有意义的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;印章耦合(stamp coupling)&lt;/p&gt;&#xA;&lt;p&gt;模块之间只有参数依赖。但是，这个参数对不同模块需要的数据是不一样的，但是提供了一个包含很多不必要的数据。比如：模块A/B都依赖结构体C，A只需要C中的a字段，B需要C的全部。这时模块A/B就冗余依赖了，就是一个印章把模块A和模块B都印上了一样。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;控制耦合(control coupling)&lt;/p&gt;&#xA;&lt;p&gt;一个模块需要传递一些控制另外一个模块执行的信息时，他们就产生了控制耦合。比如：快速排序函数中的比较函数。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;外部耦合(external coupling)&lt;/p&gt;&#xA;&lt;p&gt;多个模块同时引用相同的全局变量。全局变量是同构的，模块对全局变量的理解是一致的。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;全局耦合(common coupling)&lt;/p&gt;&#xA;&lt;p&gt;多个模块同时引用相同的全局变量。和外部变量有点类似，区别在于这些全局变量在不同模块内部的理解还不一样。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;需要的是内容耦合(content coupling)&lt;/p&gt;&#xA;&lt;p&gt;一个模块直接访问另外一个模块内部的数据。比如，某个模块直接访问某个结构体中的字段。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在上面的几种耦合中&lt;strong&gt;内容耦合&lt;/strong&gt;是&lt;strong&gt;不能接收的&lt;/strong&gt;，&lt;strong&gt;外部耦合&lt;/strong&gt;和&lt;strong&gt;全局耦合&lt;/strong&gt;是&lt;strong&gt;尽量避免&lt;/strong&gt;，但是&lt;strong&gt;有时可能没法避免&lt;/strong&gt;，&lt;strong&gt;控制耦合&lt;/strong&gt;是可以接收的，&lt;strong&gt;数据耦合&lt;/strong&gt;和&lt;strong&gt;印章耦合&lt;/strong&gt;是我们需要&lt;strong&gt;追求&lt;/strong&gt;的，最好做到数据耦合。&lt;/p&gt;&#xA;&lt;p&gt;在面向对象编程范式里面，常见的耦合有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;空间耦合&lt;/p&gt;&#xA;&lt;p&gt;把两个模块放在一起，仅仅是因为他们在同一个地方被使用了。最应该避免的一种情况。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;结构化耦合&lt;/p&gt;&#xA;&lt;p&gt;最直接的耦合。比如：一个类包含另外一个类的列表字段，一个类继承另外一个类，还有一个类的方法中定义了另外一个类的变量。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;克隆耦合&lt;/p&gt;&#xA;&lt;p&gt;代码相似，需要同时修改。比如，重复代码。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;进化耦合&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
