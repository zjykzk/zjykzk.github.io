<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>架构 on 老K随笔</title>
    <link>http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/</link>
    <description>Recent content in 架构 on 老K随笔</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>(c) 2025 zenk.</copyright>
    <lastBuildDate>Thu, 02 Apr 2020 15:41:28 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/%E6%9E%B6%E6%9E%84/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>架构模式</title>
      <link>http://localhost:1313/posts/cs/arch/pattern/</link>
      <pubDate>Thu, 02 Apr 2020 15:41:28 +0800</pubDate>
      <guid>http://localhost:1313/posts/cs/arch/pattern/</guid>
      <description>&lt;h2 id=&#34;分层架构&#34;&gt;分层架构&lt;/h2&gt;&#xA;&lt;p&gt;最简单，使用最多的架构了。一般如果不考虑架构情况下，请直接用这个架构。&lt;/p&gt;&#xA;&lt;p&gt;顾名思义，分层架构分层很多层，一般三层，但是也有很多超过三层的。每层逻辑独立。每层之间通过接口交互，上层调用下层，并且&lt;strong&gt;不跨层调用&lt;/strong&gt;。通过这种方式做到了每层的&lt;strong&gt;职责非常清晰，实现高内聚和低耦合&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;不允许跨层调用可以让依赖变得简单，易于维护。其实，有时候跨层调用却是有意义的，比如说提升性能，代价就是一层的修改会影响多层。&lt;/p&gt;&#xA;&lt;p&gt;在分层架构中，如果每层都没什么逻辑只是简单的传递调用，那就没什么意义了。有些业务逻辑是这样的，如果大部分业务逻辑都是这样的，考虑跨层调用。最好是补充这么做的文档，不然其他开发同事也可能就会做无理由的跨层调用了。&lt;/p&gt;&#xA;&lt;p&gt;// TODO pics&lt;/p&gt;&#xA;&lt;h3 id=&#34;分析&#34;&gt;分析&lt;/h3&gt;&#xA;&lt;p&gt;&lt;strong&gt;响应度&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;低。主要在单体情况下，组件之间耦合性比较高。相对来说，修改还是比较耗时。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;部署方便程度&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;低。在单体情况下，组件一修改其他都要升级。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;可测试性&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;高。上层通过接口依赖下层，每层逻辑独立。测试的时候，依赖的接口很方便mock。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;低。多一层你就需要多一次请求调用。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;扩展性&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;低。单体情况下，只能部署多个同样的实例。但是，一个实例包含着所有的逻辑，在物理上耦合在一起，没法针对性的做扩展。（再做一次垂直拆分吧！）&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;开发容易程度&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;高。架构比较流行，大家比较熟悉。同时还和公司的组织架构比较契合，公司一般有前端后端，后端又分写业务的，写基础设施的，刚好和把这些分层，符合康威定律。&lt;/p&gt;&#xA;&lt;h2 id=&#34;事件驱动架构&#34;&gt;事件驱动架构&lt;/h2&gt;&#xA;&lt;p&gt;事件驱动架构是分布式的异步架构，主要特点是业务拆分粒度细，清晰，每个业务单元高内聚，物理解耦，具有高扩展性。主要有两种拓扑结构：Mediator和Broker。&lt;/p&gt;&#xA;&lt;h3 id=&#34;mediator&#34;&gt;Mediator&lt;/h3&gt;&#xA;&lt;p&gt;Mediator拓扑由四个组件组成：event queue，event mediator，event channel，event processor。事件分为两种初始（initial event）事件和处理事件（processing event）。客户端通过event queue是把初始消息发送给event mediator。event mediator是一个中心协调者，负责业务逻辑分成多个步骤，每个步骤向event channel发送一个处理事件，并等待事件处理完成，event processor收到处理事件以后执行业务逻辑。&lt;/p&gt;&#xA;&lt;p&gt;// TODO pics&lt;/p&gt;&#xA;&lt;h3 id=&#34;broker&#34;&gt;Broker&lt;/h3&gt;&#xA;&lt;p&gt;Broker拓扑由两个组件组成：event channel和event processor。客户端往event channel发送需要处理的事件，event processor会监听event channel，当监听到自己负责的事件的时候，就会执行业务逻辑处理，处理完以后往event channel发送处理完成事件，使得其他event processor来处理接下来的业务逻辑。&lt;/p&gt;&#xA;&lt;p&gt;上面的event channel和event queue都可以通过消息队列来实现。&lt;/p&gt;&#xA;&lt;p&gt;// TODO pics&lt;/p&gt;&#xA;&lt;h3 id=&#34;分析-1&#34;&gt;分析&lt;/h3&gt;&#xA;&lt;p&gt;事件驱动架构适用于&lt;strong&gt;分布式异步&lt;/strong&gt;场景，每个业务职责单一，划分清晰。分布式的问题在这个架构下面都有。分布式事务，请求追踪等等。其中，比较复杂的问题还有维护处理事件的协议，这个和业务逻辑是强耦合的，同时一个业务逻辑被拆分成了多个事件，因此一个业务场景需要多个事件的协议，每个协议还需要考虑版本号。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;响应度&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;高。处理业务单元，逻辑简单，物理解耦，添加修改功能互相不影响。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;部署方便程度&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;高。主要还是因为处理业务单元的特点可以方便部署。Mediator比Broker要难点，因为Mediator需要感知整体业务逻辑，业务逻辑的修改都涉及到Mediator。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;可测试性&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;低。每个业务处理单元的测试还是比较简单的。但是，一个事件的整体流程测试就比较复杂。异步架构都有这个问题。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;性能&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;高。因为有event channel的存在，会把请求堆积起来（往往event channel处理的都很快），快速响应客户端。同时，每个业务处理单元能够并行处理。因此，吞吐量会很高。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;扩展性&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;高。业务处理单元特点，允许单独扩展互不影响。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;开发容易程度&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;低。业务处理单元本身开发起来还是蛮简单的。复杂的地方还是异步架构的特点，一个业务逻辑经过event channel，还有event processor，每个地方都有可能失败，错误处理复杂。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
