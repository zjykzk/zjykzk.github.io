<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Engineering on 老K随笔</title>
    <link>http://zjykzk.github.io/tags/engineering/</link>
    <description>Recent content in Engineering on 老K随笔</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>(c) 2025 zenk.</copyright>
    <lastBuildDate>Mon, 01 Jul 2024 18:13:21 +0800</lastBuildDate>
    <atom:link href="http://zjykzk.github.io/tags/engineering/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>TDD底层逻辑</title>
      <link>http://zjykzk.github.io/posts/cs/engineering/tdd/</link>
      <pubDate>Mon, 01 Jul 2024 18:13:21 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/engineering/tdd/</guid>
      <description>&lt;h1 id=&#34;一些开发常见问题&#34;&gt;一些开发常见问题&lt;/h1&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当前架构无法满足新需求，不敢修改或者新增抽象。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;一段代码变得很长，难以理解，不敢修改代码。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;开发过程中通过『跑下看看』、『打断点』的方式来测试、定位问题，效率低下（隐式QA）。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;有功能忘记写了。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;以上的问题概括起来说，代码和架构不容易维护和扩展、开发效率低。TDD作为极限编程（XP）的核心实践之一，能够比较好的解决了这些问题。&lt;/p&gt;&#xA;&lt;h1 id=&#34;测试驱动开发tdd&#34;&gt;测试驱动开发（TDD）&lt;/h1&gt;&#xA;&lt;p&gt;从上一节TDD可以解决的问题视角可以看出，TDD不是『如何写测试的技术』、『怎么消除QA』、『增加开发人员』的编码技巧。它是把测试作为里程碑的开发流程，把无计划的测试变成自动化测试提升开发效率，结合重构技巧保证代码和架构的可维护性和扩展性。&lt;/p&gt;&#xA;&lt;h2 id=&#34;测试也就是t字母&#34;&gt;测试（也就是T字母）&lt;/h2&gt;&#xA;&lt;p&gt;首先，不是传统的单元测试，也就是不涉及被测试进程之外组件的测试，而是单元级别的&lt;strong&gt;功能测试&lt;/strong&gt;。所以，也可能是传统的集成测试，但是绝对不是端到端测试；）。&lt;/p&gt;&#xA;&lt;p&gt;『功能』是指用户视角的需求拆分以后的功能，是从业务视角出发，而不是代码中的某个类、函数等。比如，『账号密码的登入』这么一个需求可以拆分成两个功能，以及对应的测试：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;账号密码正确登入成功。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;账号或者密码错误登入失败。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;但是，TDD不教你怎么写测试，写测试是TDD的必要技能，常见包括：状态验证、行为验证、怎么识别有效无效测试、怎么使用mock&amp;amp;stub等等，好测试的核心是：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;发现问题：覆盖足够多的代码，尤其是核心代码&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;稳定：代码重构的时候不会误报（错误的失败），不用修改&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;快速执行&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;容易维护：容易执行、容易理解。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;驱动也就是第一个d字母&#34;&gt;驱动（也就是第一个D字母）&lt;/h2&gt;&#xA;&lt;h3 id=&#34;驱动的是架构&#34;&gt;驱动的是『架构』&lt;/h3&gt;&#xA;&lt;p&gt;软件开发工程师开发软件首要的是：理解需求，明白架构。&lt;/p&gt;&#xA;&lt;p&gt;『理解需求』TDD无法驱动，但是能够验证是否做到了：写出测试，说明理解需求。&lt;/p&gt;&#xA;&lt;p&gt;理解需求并完成分解可以成&lt;em&gt;测试的TODO项&lt;/em&gt;之后，进入执行『红-绿-重构循环』这一TDD的核心三步骤：&lt;/p&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;红绿来自jUnit这个测试框架，失败的UT显示红色，成功的UT显示绿色。&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;红：针对单元功能编写一个失败的小测试，无法编译的也没关系；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;绿：让这个测试快速通过，任何手段都可以，甚至是错误的实现；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;重构：消除上一步中产生的坏味道。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;『红』锚定了需要实现的需求，『绿』在&lt;strong&gt;当前架构下面（如果有）的合适组件&lt;/strong&gt;下面实现刚刚锚定的需求，『重构』消除上一步中产生的各种坏味道，比如消除重复（合并组件），降低耦合（重新划分组件的职责）等等。&lt;/p&gt;&#xA;&lt;p&gt;从『驱动』视角可以看出，他并不是教你怎么编码的技术，而是一个架构技术，是以逐步演进的方式驱动架构，是一种实效主义编码架构风格（不做PPT架构师；））。&lt;/p&gt;&#xA;&lt;h3 id=&#34;极限&#34;&gt;极限&lt;/h3&gt;&#xA;&lt;p&gt;如果不会写某个测试对应的实现，TDD能驱动吗？不能！TDD无法驱动小于单元功能测试对应的需求，也无法驱动内部实现。但是，作为架构技术TDD能让你知道实现应该放在哪里，可以继续迭代其他需求，同样保持着一个有序可度量的研发节奏。至于这个需求怎么做可以找人帮忙做。&lt;/p&gt;&#xA;&lt;h2 id=&#34;执行&#34;&gt;执行&lt;/h2&gt;&#xA;&lt;h3 id=&#34;基本原则&#34;&gt;基本原则&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当且仅当存在失败的自动化测试时，才开始编写生产代码；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;消除坏味道。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;开发咒语&#34;&gt;开发咒语&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;红：针对单元功能编写一个失败的小测试，无法编译的也没关系；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;绿：让这个测试快速通过，任何手段都可以，甚至是错误的实现；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;重构：消除上一步中产生的坏味道。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;任务分解法写出测试&#34;&gt;任务分解法（写出测试）&lt;/h3&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;来自徐昊&lt;/p&gt;&lt;/blockquote&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;首先将需求分解为功能点，也就是将需求转化为一系列可验证的里程碑点；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果已经存在架构或架构愿景，则依据架构中定义的组件与交互，将功能点分解为不同的功能上下文；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果尚不存在架构愿景，则可以将功能点作为功能上下文；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将功能点按照功能上下文，分解为任务项。也就是进一步将可验证的里程碑点，分解为功能上下文中可验证的任务项；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;将任务项转化为自动化测试，进入红 / 绿 / 重构循环，驱动功能上下文内的功能实现；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果重构涉及功能上下文的重新划分，即提取 / 合并组件，即视作对于架构的重构与梳理。需调整后续功能点中对于功能上下文以及任务项的划分。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如此往复，直到所有功能完成。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../imgs/tdd.jpeg&#34; alt=&#34;tdd progres&#34;&gt;&lt;/p&gt;&#xA;&lt;h2 id=&#34;如何学习&#34;&gt;如何学习&lt;/h2&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;练，属于不可言说知识，以上内容都看懂了也不会；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;锻炼分析能力，它是支撑拆解任务基础；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;使用具有重构能力的IDE，不然变成重写。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
  </channel>
</rss>
