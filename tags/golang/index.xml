<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 老K随笔</title>
    <link>http://zjykzk.github.io/tags/golang/</link>
    <description>Recent content in Golang on 老K随笔</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>(c) 2025 zenk.</copyright>
    <lastBuildDate>Tue, 20 May 2025 10:26:00 +0800</lastBuildDate>
    <atom:link href="http://zjykzk.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>gofmt原理分析二</title>
      <link>http://zjykzk.github.io/posts/cs/golang/formatter1/</link>
      <pubDate>Tue, 20 May 2025 10:26:00 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/golang/formatter1/</guid>
      <description>&lt;p&gt;说明以下代码格式化：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// comments&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;var/const/(/)&lt;/code&gt;的格式化比较简单，基本上类似如下代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;println(&lt;span style=&#34;color:#a6e22e&#34;&gt;indents&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;var (&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\f&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;println(&lt;span style=&#34;color:#a6e22e&#34;&gt;indents&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\f&amp;#34;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// indents: 表示缩进格式&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;圆括号内部稍微复杂些。内部的一条语句叫做 var spec，其完整形式是这样的：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;idents&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Type&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;values&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// comments&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// e.g.&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// just some comments&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// idents: 变量列表&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Type: 类型&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// values: 值表达式列表&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// comments: 注释&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;输出格式&lt;code&gt;idents|Type|= values|comments&lt;/code&gt;其中&lt;code&gt;|&lt;/code&gt;表示&lt;code&gt;\v&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;但是，其中&lt;code&gt;Type/=/values/comments&lt;/code&gt;都是可以省略的（其中&lt;code&gt;=/values&lt;/code&gt;是一起出现的）。&lt;/p&gt;&#xA;&lt;p&gt;有几个格式化规则：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;如果有&lt;code&gt;Type&lt;/code&gt;，前面跟着一个&lt;code&gt;|&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;|&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;&#xA;&lt;li&gt;如果没有&lt;code&gt;Type&lt;/code&gt;，需要看当前var spec的前后多行，往前或者往后能够找到一个包含&lt;code&gt;Type&lt;/code&gt;的var spec，而且中间没有仅仅只有&lt;code&gt;idents&lt;/code&gt;的var spec，那么&lt;code&gt;idents&lt;/code&gt;后面需要跟着一个&lt;code&gt;|&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// example&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;|&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;= &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;k&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;y&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;如果有&lt;code&gt;values&lt;/code&gt;，&lt;code&gt;values&lt;/code&gt;之前需要&lt;code&gt;|=&lt;/code&gt; ；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;4&#34;&gt;&#xA;&lt;li&gt;如果有comments，&lt;code&gt;idents&lt;/code&gt;和&lt;code&gt;comments&lt;/code&gt;之间必须有三个&lt;code&gt;|&lt;/code&gt;；&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// example1&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;j&lt;/span&gt;|&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;|&lt;span style=&#34;color:#75715e&#34;&gt;// comments&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// example2&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;|=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// just some comments&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// example3&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;i&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt;|&lt;span style=&#34;color:#75715e&#34;&gt;// comments&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>gofmt原理分析一</title>
      <link>http://zjykzk.github.io/posts/cs/golang/formatter/</link>
      <pubDate>Sat, 10 May 2025 21:10:21 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/golang/formatter/</guid>
      <description>&lt;h1 id=&#34;缩进&#34;&gt;缩进&lt;/h1&gt;&#xA;&lt;p&gt;核心数据结构：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; (&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;indent&lt;/span&gt;   = &lt;span style=&#34;color:#a6e22e&#34;&gt;whiteSpace&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;unindent&lt;/span&gt; = &lt;span style=&#34;color:#a6e22e&#34;&gt;whiteSpace&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;lt;&amp;#39;&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;printer&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;indent&lt;/span&gt;       &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;          &lt;span style=&#34;color:#75715e&#34;&gt;// current indentation&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;wsbuf&lt;/span&gt;        []&lt;span style=&#34;color:#a6e22e&#34;&gt;whiteSpace&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// delayed white space&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/master/src/go/printer/printer.go#L68&#34;&gt;&lt;code&gt;printer.wsbuf&lt;/code&gt;&lt;/a&gt;记录&lt;a href=&#34;https://github.com/golang/go/blob/master/src/go/printer/printer.go#L35&#34;&gt;&lt;code&gt;indent&lt;/code&gt;&lt;/a&gt;和&lt;a href=&#34;https://github.com/golang/go/blob/master/src/go/printer/printer.go#L36&#34;&gt;&lt;code&gt;unindent&lt;/code&gt;&lt;/a&gt;两个常量；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;a href=&#34;https://github.com/golang/go/blob/master/src/go/printer/printer.go#L61&#34;&gt;&lt;code&gt;printer.indent&lt;/code&gt;&lt;/a&gt;字段保存当前缩进个数, 当在调用函数&lt;a href=&#34;https://github.com/golang/go/blob/master/src/go/printer/printer.go#L817&#34;&gt;&lt;code&gt;writeWhitespace&lt;/code&gt;&lt;/a&gt;时会遍历&lt;code&gt;wsbuf&lt;/code&gt;遇到&lt;code&gt;indent&lt;/code&gt;值加1，遇到&lt;code&gt;unindent&lt;/code&gt;时减一；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当调用写入数据函数的时候，如果当前列是第一列就写入缩进；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h1 id=&#34;二元表达式&#34;&gt;二元表达式&lt;/h1&gt;&#xA;&lt;h2 id=&#34;缩进-1&#34;&gt;缩进&lt;/h2&gt;&#xA;&lt;p&gt;生成：运算符和右边的表达式不在同一行，会在格式化右边表达式之前多一个缩进；&lt;/p&gt;&#xA;&lt;p&gt;消除：右边的表达式格式化完成以后，会减少一个缩进；&lt;/p&gt;&#xA;&lt;h2 id=&#34;空格&#34;&gt;空格&lt;/h2&gt;&#xA;&lt;p&gt;运算符前后是否需要空格，比如：&lt;code&gt;a +b&lt;/code&gt;中&lt;code&gt;+&lt;/code&gt;左边有空格，右边没有空格。它的计算依赖一个&lt;strong&gt;优先级分隔符&lt;/strong&gt;概念，它的值是一个优先级。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优先级分隔符大于当前运算符优先级：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;运算符左边有空格；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;如果运算符和右表达式没有空行，运算符右边也有空格，否则没有空格；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优先级分隔符小于等于当前运算符优先级：运算符左右都没有空格。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;表达式深度&#34;&gt;表达式深度&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;初始深度是1；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;左操作数的深度以下两种情况会增加1：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;不是二元表达式&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;是二元表达式，并且运算符的优先级和当前运算符一致；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;右操作数的深度增加1；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;操作数是圆括号的话，比如：&lt;code&gt;(a+b)&lt;/code&gt;减一，但是不会小于1；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h4 id=&#34;模式&#34;&gt;模式&lt;/h4&gt;&#xA;&lt;p&gt;根据表达式深度的大小定义两种模式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;普通模式：表达式深度等于1；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;紧凑模式：表达式深度大于1；&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;优先级分隔符&#34;&gt;优先级分隔符&lt;/h3&gt;&#xA;&lt;h4 id=&#34;运算符优先级&#34;&gt;运算符优先级&lt;/h4&gt;&#xA;&lt;table&gt;&#xA;  &lt;thead&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;th&gt;运算符&lt;/th&gt;&#xA;          &lt;th&gt;优先级&lt;/th&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/thead&gt;&#xA;  &lt;tbody&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;*  /  %  &amp;lt;&amp;lt;  &amp;gt;&amp;gt;  &amp;amp;  &amp;amp;^&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;5&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;+  -  |  ^&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;4&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;==  !=  &amp;lt;  &amp;lt;=  &amp;gt;  &amp;gt;=&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;3&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;2&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;      &lt;tr&gt;&#xA;          &lt;td&gt;&lt;code&gt;||&lt;/code&gt;&lt;/td&gt;&#xA;          &lt;td&gt;1&lt;/td&gt;&#xA;      &lt;/tr&gt;&#xA;  &lt;/tbody&gt;&#xA;&lt;/table&gt;&#xA;&lt;h4 id=&#34;规则&#34;&gt;规则&lt;/h4&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;优先级小于等于3时，运算符左右边都有空格；&lt;/p&gt;</description>
    </item>
    <item>
      <title>sync.Map实现分析</title>
      <link>http://zjykzk.github.io/posts/cs/golang/sync.map/</link>
      <pubDate>Wed, 29 May 2019 14:44:31 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/golang/sync.map/</guid>
      <description>&lt;p&gt;golang的SDK中提供线程安全的map实现&lt;code&gt;sync.Map&lt;/code&gt;。它是针对&lt;code&gt;RWMutex+map&lt;/code&gt;的实现方案中存在cache line的false share提出来的。主要适用于两个场景：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;针对一个key一次写多次读。&lt;/li&gt;&#xA;&lt;li&gt;多个goroutine并发读写修改的key是没有交集。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;在这两种情况下，相比一个&lt;code&gt;Mutex&lt;/code&gt;或者&lt;code&gt;RWMutex&lt;/code&gt;加上普通的map，锁的竞争要少的多。那为什么呢？&lt;/p&gt;&#xA;&lt;h3 id=&#34;数据结构&#34;&gt;数据结构&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Map struct {&#xA;  mu Mutex&#xA;&#xA;  // read contains the portion of the map&amp;#39;s contents that are safe for&#xA;  // concurrent access (with or without mu held).&#xA;  //&#xA;  // The read field itself is always safe to load, but must only be stored with&#xA;  // mu held.&#xA;  //&#xA;  // Entries stored in read may be updated concurrently without mu, but updating&#xA;  // a previously-expunged entry requires that the entry be copied to the dirty&#xA;  // map and unexpunged with mu held.&#xA;  read atomic.Value // readOnly&#xA;&#xA;  // dirty contains the portion of the map&amp;#39;s contents that require mu to be&#xA;  // held. To ensure that the dirty map can be promoted to the read map quickly,&#xA;  // it also includes all of the non-expunged entries in the read map.&#xA;  //&#xA;  // Expunged entries are not stored in the dirty map. An expunged entry in the&#xA;  // clean map must be unexpunged and added to the dirty map before a new value&#xA;  // can be stored to it.&#xA;  //&#xA;  // If the dirty map is nil, the next write to the map will initialize it by&#xA;  // making a shallow copy of the clean map, omitting stale entries.&#xA;  dirty map[interface{}]*entry&#xA;&#xA;  // misses counts the number of loads since the read map was last updated that&#xA;  // needed to lock mu to determine whether the key was present.&#xA;  //&#xA;  // Once enough misses have occurred to cover the cost of copying the dirty&#xA;  // map, the dirty map will be promoted to the read map (in the unamended&#xA;  // state) and the next store to the map will make a new dirty copy.&#xA;  misses int&#xA;}&#xA;&#xA;// readOnly is an immutable struct stored atomically in the Map.read field.&#xA;type readOnly struct {&#xA;  m       map[interface{}]*entry&#xA;  amended bool // true if the dirty map contains some key not in m.&#xA;}&#xA;&#xA;// An entry is a slot in the map corresponding to a particular key.&#xA;type entry struct {&#xA;  // p points to the interface{} value stored for the entry.&#xA;  //&#xA;  // If p == nil, the entry has been deleted and m.dirty == nil.&#xA;  //&#xA;  // If p == expunged, the entry has been deleted, m.dirty != nil, and the entry&#xA;  // is missing from m.dirty.&#xA;  //&#xA;  // Otherwise, the entry is valid and recorded in m.read.m[key] and, if m.dirty&#xA;  // != nil, in m.dirty[key].&#xA;  //&#xA;  // An entry can be deleted by atomic replacement with nil: when m.dirty is&#xA;  // next created, it will atomically replace nil with expunged and leave&#xA;  // m.dirty[key] unset.&#xA;  //&#xA;  // An entry&amp;#39;s associated value can be updated by atomic replacement, provided&#xA;  // p != expunged. If p == expunged, an entry&amp;#39;s associated value can be updated&#xA;  // only after first setting m.dirty[key] = e so that lookups using the dirty&#xA;  // map find the entry.&#xA;  p unsafe.Pointer // *interface{}&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;code&gt;Map.read&lt;/code&gt;包含了部分数据，读写请求优先考虑&lt;code&gt;read&lt;/code&gt;，针对它的操作都是CAS，无锁的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>为什么main函数是终结者</title>
      <link>http://zjykzk.github.io/posts/cs/golang/how-main-goroutine-is-terminator/</link>
      <pubDate>Fri, 16 Nov 2018 14:13:32 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/golang/how-main-goroutine-is-terminator/</guid>
      <description>&lt;p&gt;来一个&lt;code&gt;hello, world!&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;package main&#xA;&#xA;func main() {&#xA;    println(&amp;#34;hello, world!&amp;#34;)&#xA;} // line 5&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译调试。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# go build -o debug_main main.go // 编译&#xA;# gdb debug_main                 // 开始调试&#xA;(gdb) b 5 // 在第5行打断点&#xA;(gdb) r   // 执行，这时代码停在第5行，还在main函数中，其实在二进制文件里面它符号是main_main&#xA;(gdb) s   // 单步往下走，进入runtime.main代码&#xA;runtime.main () at /home/zenk/tools/goroot/src/runtime/proc.go:207&#xA;207             if atomic.Load(&amp;amp;runningPanicDefers) != 0 {&#xA;(gdb) bt  // 查看调用栈&#xA;#0  runtime.main () at /home/zenk/tools/goroot/src/runtime/proc.go:207&#xA;#1  0x0000000000446891 in runtime.goexit () at /home/zenk/tools/goroot/src/runtime/asm_amd64.s:2361&#xA;#2  0x0000000000000000 in ?? ()&#xA;(gdb) s&#xA;216             if atomic.Load(&amp;amp;panicking) != 0 {&#xA;(gdb) s&#xA;220             exit(0)&#xA;(gdb) s&#xA;runtime.exit () at /home/zenk/tools/goroot/src/runtime/sys_linux_amd64.s:52&#xA;52              MOVL    code+0(FP), DI&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上面的结果可以知道，自己写的&lt;code&gt;main&lt;/code&gt;函数被编译成&lt;code&gt;main_main&lt;/code&gt;，然后被&lt;code&gt;runtime.main&lt;/code&gt;所调用。通过查看&lt;code&gt;runtime.main&lt;/code&gt;可以看到以下代码，说明它执行结束以后会调用&lt;code&gt;exit(0)&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>golang中的tls</title>
      <link>http://zjykzk.github.io/posts/cs/golang/tls/</link>
      <pubDate>Tue, 27 Feb 2018 19:51:16 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/golang/tls/</guid>
      <description>&lt;p&gt;在golang中，为了性能的目的，当前执行的&lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/runtime2.go#L332&#34;&gt;&lt;code&gt;g&lt;/code&gt;&lt;/a&gt;是保存在当前线程的TLS中的，而TLS的地址在结构体&lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/runtime2.go#L412&#34;&gt;&lt;code&gt;m&lt;/code&gt;&lt;/a&gt;里面。问题是怎么放进去的呢？&lt;/p&gt;&#xA;&lt;p&gt;可以从程序的启动入手，顺藤摸瓜。&lt;/p&gt;&#xA;&lt;p&gt;编写一个打印&lt;code&gt;hello,world&lt;/code&gt;的程序&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// hello.go&#xA;&#xA;package main&#xA;&#xA;func main() {&#xA;        print(&amp;#34;hello, world&amp;#34;)&#xA;}&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编译生成可执行文件&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go build -o hello hello.go&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;用gdb进行调试，找到程序的入口 &lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/rt0_linux_amd64.s#L7&#34;&gt;&lt;code&gt;_rt0_amd64_linux&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;gdb hello&#xA;(gdb) info files&#xA;...&#xA;Entry point: 0x448f20&#xA;...&#xA;(gdb) list *0x448f20&#xA;0x448f20 is in _rt0_amd64_linux (/home/zenk/tools/goroot/src/runtime/rt0_linux_amd64.s:8)&#xA;3       // license that can be found in the LICENSE file.&#xA;4&#xA;5       #include &amp;#34;textflag.h&amp;#34;&#xA;6&#xA;7       TEXT _rt0_amd64_linux(SB),NOSPLIT,$-8&#xA;8               LEAQ    8(SP), SI // argv&#xA;9               MOVQ    0(SP), DI // argc&#xA;10              MOVQ    $main(SB), AX&#xA;11              JMP     AX&#xA;12&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;发现&lt;code&gt;_rt0_amd64_linux&lt;/code&gt;调用了&lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/rt0_linux_amd64.s#L72&#34;&gt;&lt;code&gt;main&lt;/code&gt;&lt;/a&gt;函数，后者调用了&lt;a href=&#34;https://github.com/golang/go/blob/release-branch.go1.8/src/runtime/asm_amd64.s#L10&#34;&gt;&lt;code&gt;runtime.rt0_go&lt;/code&gt;&lt;/a&gt;。而在函数&lt;code&gt;runtime.rt0_go&lt;/code&gt;中&lt;/p&gt;</description>
    </item>
    <item>
      <title>map 内部实现</title>
      <link>http://zjykzk.github.io/posts/cs/golang/map/</link>
      <pubDate>Thu, 15 Jun 2017 19:13:25 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/golang/map/</guid>
      <description>&lt;h1 id=&#34;类型&#34;&gt;类型&lt;/h1&gt;&#xA;&lt;p&gt;golang中的map是一个 &lt;strong&gt;指针&lt;/strong&gt;。当执行语句 &lt;code&gt;make(map[string]string)&lt;/code&gt; 的时候，其实是调用了 &lt;code&gt;makemap&lt;/code&gt; 函数：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// file: runtime/hashmap.go:L222&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;func&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;makemap&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;t&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;maptype&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;hint64&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;h&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;bucket&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;显然，&lt;code&gt;makemap&lt;/code&gt; 返回的是指针。&lt;/p&gt;&#xA;&lt;h1 id=&#34;数据结构&#34;&gt;数据结构&lt;/h1&gt;&#xA;&lt;h2 id=&#34;hashmap&#34;&gt;hashmap&lt;/h2&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// hash map&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;hmap&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 元素的个数 == len()返回的值，必须放在第一个位置因为 len函数需要使用&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;count&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// map标记:&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. key和value是否包指针&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 是否正在扩容&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 是否是同样大小的扩容&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 是否正在 `range`方式访问当前的buckets&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 5. 是否有 `range`方式访问旧的bucket&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;flags&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;B&lt;/span&gt;         &lt;span style=&#34;color:#66d9ef&#34;&gt;uint8&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;// log_2(B) == bucket数量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;noverflow&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;uint16&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// overflow bucket的数量，是个近似值&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;hash0&lt;/span&gt;     &lt;span style=&#34;color:#66d9ef&#34;&gt;uint32&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// hash种子&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;buckets&lt;/span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// bucket slice指针，如果count == 0，这里的值为 nil&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;oldbuckets&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;unsafe&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;Pointer&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;// bucket slice指针，仅当在扩容的时候不为nil&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;nevacuate&lt;/span&gt;  &lt;span style=&#34;color:#66d9ef&#34;&gt;uintptr&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;// 扩容时已经移到新的map中的bucket数量&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 当key和value的类型不包含指针的时候，key和value就会做inline处理(怎么处理的)&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 保证overflow的bucket活着，不被gc回收&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;overflow&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;[]&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bmap&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;bucket&#34;&gt;bucket&lt;/h2&gt;&#xA;&lt;p&gt;每个bucket固定包含8个key和value。实现上面是一个固定的大小连续内存块，分成四部分：&lt;/p&gt;</description>
    </item>
    <item>
      <title>GO 内存模型</title>
      <link>http://zjykzk.github.io/posts/cs/golang/go-memory-model/</link>
      <pubDate>Tue, 28 Mar 2017 11:22:09 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/golang/go-memory-model/</guid>
      <description>&lt;p&gt;内存模型定义了一系列的条件，在这些条件下，多个goroutine对一个变量进行读写，保证一个goroutine读取到的值是是另外一个goroutine写入的某个值。&lt;/p&gt;&#xA;&lt;h2 id=&#34;happens-before&#34;&gt;Happens Before&lt;/h2&gt;&#xA;&lt;p&gt;编译器会对程序做优化，比如指令重排。在go语言中规定，在同一个goroutine里面，程序表达的顺序就是读写的顺序。但是，多个goroutine执行同样的代码时，就会出现读写顺序不一样的情况。例如，代码：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在编译器的优化下，代码的执行顺序有可能变成下面这样的情况：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#a6e22e&#34;&gt;a&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt; = &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;print(&lt;span style=&#34;color:#a6e22e&#34;&gt;b&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;但是，多个goroutine执行时，就无法保证打印&lt;em&gt;a&lt;/em&gt;的时候，&lt;em&gt;b&lt;/em&gt;的值一定是1.&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;happens before&lt;/strong&gt;定义了内存操作的顺序，它是一种偏序。&lt;em&gt;e1&lt;/em&gt; happens before &lt;em&gt;e2&lt;/em&gt;, &lt;em&gt;e2&lt;/em&gt; happens after &lt;em&gt;e1&lt;/em&gt; 。如果 &lt;em&gt;e1&lt;/em&gt; 既不happens before &lt;em&gt;e2&lt;/em&gt; 也不happens after &lt;em&gt;e2&lt;/em&gt; ，那么 &lt;em&gt;e1&lt;/em&gt; 和 &lt;em&gt;e2&lt;/em&gt; 是并发执行的。它有传递的性质（自反性，对称性就不考虑了）。这个关系就决定了共享变量在某个上下文下面读写顺序，那么它的具体值变化也就确定了。&lt;/p&gt;&#xA;&lt;p&gt;&lt;em&gt;在一个goroutine中，happens before的顺序就是代码表达的顺序。&lt;/em&gt;&lt;/p&gt;&#xA;&lt;p&gt;共享变量 &lt;em&gt;v&lt;/em&gt; 的读操作 &lt;em&gt;r&lt;/em&gt; ，能够读到是另一个对变量 &lt;em&gt;v&lt;/em&gt; 写操作 &lt;em&gt;w&lt;/em&gt; 写入的值的条件是：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;em&gt;w&lt;/em&gt; happens before &lt;em&gt;r&lt;/em&gt;&lt;/li&gt;&#xA;&lt;li&gt;没有其他的对变量 &lt;em&gt;v&lt;/em&gt; 写操作happens before &lt;em&gt;r&lt;/em&gt; 并且happens after &lt;em&gt;w&lt;/em&gt;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这两个条件并不能保证有一个与 &lt;em&gt;r&amp;amp;w&lt;/em&gt; 没有任何happens before关系的对共享变量 &lt;em&gt;v&lt;/em&gt; 写操作 &lt;em&gt;w&amp;rsquo;&lt;/em&gt; 的存在，导致 &lt;em&gt;r&lt;/em&gt; 读到的是 &lt;em&gt;w&amp;rsquo;&lt;/em&gt; 的结果。所以，保证 &lt;em&gt;r&lt;/em&gt; 的结果是 &lt;em&gt;w&lt;/em&gt; 的值的条件是：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
