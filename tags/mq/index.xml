<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Mq on 老K随笔</title>
    <link>http://zjykzk.github.io/tags/mq/</link>
    <description>Recent content in Mq on 老K随笔</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>(c) 2025 zenk.</copyright>
    <lastBuildDate>Fri, 25 Jan 2019 15:35:52 +0800</lastBuildDate>
    <atom:link href="http://zjykzk.github.io/tags/mq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RocketMQ HA实现</title>
      <link>http://zjykzk.github.io/posts/cs/rocketmq/ha/</link>
      <pubDate>Fri, 25 Jan 2019 15:35:52 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/rocketmq/ha/</guid>
      <description>&lt;h2 id=&#34;ha原理&#34;&gt;HA原理&lt;/h2&gt;&#xA;&lt;p&gt;RocketMQ支持主结点的数据同步到从结点。同步的数据依赖于当前从结点的状态。从结点连接到主结点的时候会上报自己的当前commitlog的最大偏移量。主结点收到以后会根据这个值计算出传输的起始位置，如果上报的commitlog的最大偏移量：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;等于0，主结点会从当前最大偏移量减去一个log文件大小那个位置开始传输。如果小于0，那么从0开始传输。&lt;/li&gt;&#xA;&lt;li&gt;大于0，从该值开始传输。&lt;/li&gt;&#xA;&lt;li&gt;小于0，这种情况不存在。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;所以，这里我们可以知道如果从结点已经就有数据情况，如果数据不是从主结点同步过来的，那么同步之后就会有问题了。比如说：从结点已经有10000条数据，同时某个topic，暂时就叫&lt;strong&gt;OLD_TOPIC&lt;/strong&gt;的&lt;em&gt;消费队列0&lt;/em&gt;长度1000。这个时候，主结点就会从第10000条数据开始同步，可能会发送几种情况：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;主结点没有10000数据，那么就不会同步数据，造成从结点上面数据丢失。&lt;/li&gt;&#xA;&lt;li&gt;主结点有超过10000数据，但是它的&lt;strong&gt;OLD_TOPIC&lt;/strong&gt;的&lt;em&gt;消费队列0&lt;/em&gt;的长度小于1000，那么同步过来的数据就会覆盖原来的数据。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;所以，从结点的初始状态需要从0开始或者本来就是和主同步过的状态。因此，在删除topic的时候从结点要保证删除干净，不然从结点就会脏数据，影响消费。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;为什么这样同步不会有问题呢？&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;p&gt;那是因为同步的数据里面包含了具体消费队列ID，队列中的偏移量以及消息的偏移量，所以同步的时候能够写到同一个位置。&lt;/p&gt;&#xA;&lt;h2 id=&#34;主结点同步逻辑&#34;&gt;主结点同步逻辑&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../imgs/rocketmq/ha-master.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;发送一条消息的时候，在开启&lt;strong&gt;SYNC_MASTER&lt;/strong&gt;情况下，需要四个线程合作才能完成消息的发送。&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;SendMessageProcessor&lt;/strong&gt;负责处理接收发送消息的请求并落盘（异步或者同步），接着向&lt;strong&gt;GroupTransferService&lt;/strong&gt;发送等待同步完成的请求，然后等待知道超时或者&lt;strong&gt;GroupTransferService&lt;/strong&gt;通知同步完成。同时，还会同时&lt;strong&gt;WriteSocketService&lt;/strong&gt;有数据可以写了。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;WriteSocketService&lt;/strong&gt;负责根据从结点上报的位置（变量&lt;code&gt;slaveRequestOffset&lt;/code&gt;），不断的向从结点传输数据。同时会维护和从结点的一个心跳，如果一段时间没有通不过数据，就会发送一个消息头，包含当前同步的起始位置。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;GroupTransferService&lt;/strong&gt;不断的轮询比较当前已经被从结点同步的最大偏移（变量&lt;code&gt;push2SlaveMaxOffset&lt;/code&gt;）和&lt;strong&gt;SendMessageProcessor&lt;/strong&gt;发送过来的请求中包含的偏移量，如果大于或者等于就会通知&lt;strong&gt;SendMessageProcessor&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;ReadSocketService&lt;/strong&gt;负责读取从结点上报上来的同步偏移量。更新变量&lt;code&gt;push2SlaveMaxOffset&lt;/code&gt;和&lt;code&gt;slaveRequestOffset&lt;/code&gt;并通知&lt;strong&gt;GroupTransferService&lt;/strong&gt;。从而，它也会影响&lt;strong&gt;WriteSocketService&lt;/strong&gt;的行为。同时，它还维护着和从结点连接的过期工作，如果超过指定时间没有收到消息就会断开连接，同时会停止&lt;strong&gt;WriteSocketService&lt;/strong&gt;。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;从结点同步逻辑&#34;&gt;从结点同步逻辑&lt;/h2&gt;&#xA;&lt;p&gt;&lt;img src=&#34;../../imgs/rocketmq/ha-slave.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;&#xA;&lt;p&gt;从结点的同步逻辑相对简单主要做几件事情：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;管理和主结点的连接，如果超过一段时间没有收到主点结点的数据，就会断开连接。这个时间戳保存在变量&lt;code&gt;lastWriteTimestamp&lt;/code&gt;中，刚刚连接上主结点和从主结点读到数据都会更新该变量。&lt;/li&gt;&#xA;&lt;li&gt;上报当前commitlog的最大偏移量，该行为会发生三个地方：a.写完一个消息；b.处理完当前收到的所有数据；c.一段时间内没有收到主结点的数据。&lt;/li&gt;&#xA;&lt;li&gt;维护收到的数据。这里有两个接收数据的buffer，主要方便处理当一个buffer的空间用完以后处理剩余的消息。一个buffer的情况下，先拷贝到一个临时byte数据，然后再拷贝回去，需要两次内存拷贝。如果两个buffer只需要一次拷贝。&lt;/li&gt;&#xA;&lt;li&gt;写消息。把从主结点同步过来的数据写到磁盘。收到数据的时候会判断主结点发过来的偏移量是否等于自己当前的偏移量如果不一样就会断开和主结点的连接。&lt;/li&gt;&#xA;&lt;li&gt;任何从连接中读数据的时候如果有错误就会断开连接。&lt;/li&gt;&#xA;&lt;/ol&gt;</description>
    </item>
    <item>
      <title>slave和master同步连接经常重连，导致发送消息失败</title>
      <link>http://zjykzk.github.io/posts/cs/rocketmq/slave-sync-from-master-disconnect/</link>
      <pubDate>Mon, 22 Oct 2018 17:07:02 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/rocketmq/slave-sync-from-master-disconnect/</guid>
      <description>&lt;h2 id=&#34;缘起&#34;&gt;缘起&lt;/h2&gt;&#xA;&lt;p&gt;封装RocketMQ的组件boots-broker每天都返回几个的500。排查发现是因为slave向master同步消息的时候，由于没有及时向master报告自己的同步进度，从而master没有向slave及时同步消息，导致消息发送失败。&lt;/p&gt;&#xA;&lt;h2 id=&#34;排查过程&#34;&gt;排查过程&lt;/h2&gt;&#xA;&lt;p&gt;查看boots-broker日志，发现问题日志：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[TIMEOUT_CLEAN_QUEUE]broker busy, start flow control for a while, period in queue: 1008ms, size of queue: 0&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;说明，RocketMQ处理发送消息比较慢。可是，从&lt;code&gt;size of queue&lt;/code&gt;可以看出，堆积的消息为0。&lt;/p&gt;&#xA;&lt;p&gt;查看机器资源消耗情况，发现资源都是充裕的。&lt;/p&gt;&#xA;&lt;p&gt;查看RocketMQ日志，发现store.log中有异常，master中的store.log周期性的发生以下日志：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;2018-10-22 15:44:07 INFO AcceptSocketService - HAService receive new connection, /10.38.34.27:54052&#xA;2018-10-22 15:44:07 INFO ReadSocketService - ReadSocketService service started&#xA;2018-10-22 15:44:07 INFO WriteSocketService - WriteSocketService service started&#xA;2018-10-22 15:44:08 INFO WriteSocketService - WriteSocketService service end&#xA;2018-10-22 15:44:12 INFO ReadSocketService - slave[/10.38.34.27:54052] request offset 157843228&#xA;2018-10-22 15:44:12 INFO WriteSocketService - master transfer data from 157843228 to slave[/10.38.34.27:54052], and slave request 157843228&#xA;2018-10-22 15:44:33 WARN ReadSocketService - ha housekeeping, found this connection[/10.38.34.27:54052] expired, 20019&#xA;2018-10-22 15:44:33 INFO ReadSocketService - ReadSocketService service end&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;从上可以看出，slave主动向master建立连接，5s之后发送自己当前同步的进度，master收到以后向slave发送同步数据，最后master由于slave的连接过期，主动断开连接。&lt;/p&gt;</description>
    </item>
    <item>
      <title>rocketmq store模块</title>
      <link>http://zjykzk.github.io/posts/cs/rocketmq/store/</link>
      <pubDate>Fri, 08 Dec 2017 17:59:56 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/rocketmq/store/</guid>
      <description>&lt;h2 id=&#34;功能&#34;&gt;功能&lt;/h2&gt;&#xA;&lt;p&gt;store模块是rocketmq的核心模块。主要功能有：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;消息存储&lt;/li&gt;&#xA;&lt;li&gt;消息索引&lt;/li&gt;&#xA;&lt;li&gt;消费队列&lt;/li&gt;&#xA;&lt;li&gt;主从同步&lt;/li&gt;&#xA;&lt;li&gt;延迟消息&lt;/li&gt;&#xA;&lt;li&gt;清理过期的消息和消费队列&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;消息存储&#34;&gt;消息存储&lt;/h2&gt;&#xA;&lt;p&gt;负责消息存储，包括写消息，刷盘。&lt;/p&gt;&#xA;&lt;h3 id=&#34;消息文件&#34;&gt;消息文件&lt;/h3&gt;&#xA;&lt;p&gt;消息保存在默认值为&lt;code&gt;${user.home}\store\commitlog&lt;/code&gt;文件夹下，可以通过配置项&lt;code&gt;storePathCommitLog&lt;/code&gt;修改。所有的消息都写入一个逻辑文件，每个逻辑文件包含大小相等的物理文件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;写消息&#34;&gt;写消息&lt;/h3&gt;&#xA;&lt;p&gt;写消息在不同的场景下面会有不同的逻辑。&lt;/p&gt;&#xA;&lt;h4 id=&#34;同步刷盘&#34;&gt;同步刷盘&lt;/h4&gt;&#xA;&lt;p&gt;每条消息要写到磁盘以后才算完成。&lt;/p&gt;&#xA;&lt;p&gt;在同步刷盘的场景下，会有一个定期检查消息是否已经写入磁盘的线程：&lt;code&gt;GroupCommitService&lt;/code&gt;，除了检查还会进行刷盘的操作 。写消息的时候会生成一个&lt;code&gt;GroupCommitRequest&lt;/code&gt;提交到&lt;code&gt;GroupCommitService&lt;/code&gt;，并等待被唤醒或者超时。当&lt;code&gt;GroupCommitService&lt;/code&gt;发现已经刷盘的最后一个消息的索引大于等于本消息的索引时就会唤醒&lt;code&gt;GroupCommitRequest&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;备注&lt;/strong&gt;：以上的场景还依赖于消息的属性&lt;code&gt;WAIT&lt;/code&gt;，只有该属性为空或者为&lt;code&gt;true&lt;/code&gt;才会执行同步刷盘逻辑，默认是空的。&lt;/p&gt;&#xA;&lt;h4 id=&#34;异步刷盘&#34;&gt;异步刷盘&lt;/h4&gt;&#xA;&lt;p&gt;在异步刷盘的场景下，会有一个把数据刷到磁盘的辅助线程：&lt;code&gt;FlushRealTimeService&lt;/code&gt;。写消息仅仅唤醒该线程就结束了写盘操作。&lt;/p&gt;&#xA;&lt;h4 id=&#34;主从同步&#34;&gt;主从同步&lt;/h4&gt;&#xA;&lt;p&gt;每条消息要等一个从broker同步完才算完成。&lt;/p&gt;&#xA;&lt;p&gt;在主从同步的场景下，会有一个定期检查消息是否已经被从broker同步的辅助线程：&lt;code&gt;GroupTransferService&lt;/code&gt;。写消息的时候会生成一个&lt;code&gt;GroupCommitRequest&lt;/code&gt;提交给&lt;code&gt;GroupTransferService&lt;/code&gt;，并等待被唤醒或者超时。当&lt;code&gt;GroupTransferService&lt;/code&gt;发现从broker已经同步的最后一个消息的索引大于本次消息的索引时就会唤醒&lt;code&gt;GroupCommitRequest&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;h4 id=&#34;写buffer&#34;&gt;写buffer&lt;/h4&gt;&#xA;&lt;p&gt;使用了写buffer以后，写消息的全部逻辑就是把消息写入buffer。同时，系统会有一个线程&lt;code&gt;CommitRealTimeService&lt;/code&gt;定期把消息写入文件。&lt;/p&gt;&#xA;&lt;h3 id=&#34;核心代码&#34;&gt;核心代码&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;org.apache.rocketmq.store.CommitLog&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;消费队列&#34;&gt;消费队列&lt;/h2&gt;&#xA;&lt;p&gt;每个topic对应多个消费队列，这个是提高消费并发度的前提。&lt;/p&gt;&#xA;&lt;h3 id=&#34;结构&#34;&gt;结构&lt;/h3&gt;&#xA;&lt;p&gt;每个消费队列对应一个逻辑文件，文件中对应每个消息的内容大小是固定的20个字节，包含消息的偏移量，大小以及tag哈希值。&lt;/p&gt;&#xA;&lt;h4 id=&#34;文件目录&#34;&gt;文件目录&lt;/h4&gt;&#xA;&lt;p&gt;数据保存在目录&lt;code&gt;${rootpath}/consumequeue&lt;/code&gt;下面，&lt;code&gt;rootpath&lt;/code&gt; 通过配置项&lt;code&gt;storePathRootDir&lt;/code&gt;指定，默认的是&lt;code&gt;${user.home}/store&lt;/code&gt;。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;${rootpath}/consumequeue&#xA;└── 0%default                     // topic&#xA;    ├── 0                         // queue 0&#xA;    │   └── 00000000000000000000&#xA;    ├── 1                         // queue 1&#xA;    │   └── 00000000000000000000&#xA;    ├── 2                         // queue 2&#xA;    │   └── 00000000000000000000&#xA;    └── 3                         // queue 3&#xA;        └── 00000000000000000000&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;队列元素&#34;&gt;队列元素&lt;/h4&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;|&amp;lt;----- 8 byte -----&amp;gt;|&amp;lt;- 4 byte -&amp;gt;|&amp;lt;------ 8 byte ------&amp;gt;|&#xA;+--------------------+------------+----------------------+&#xA;|   commitlog offset |   size     | message tag hash code|&#xA;+--------------------+------------+----------------------+&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;执行&#34;&gt;执行&lt;/h3&gt;&#xA;&lt;p&gt;通过线程&lt;code&gt;ReputMessageService&lt;/code&gt;的分派消息的逻辑执行。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
