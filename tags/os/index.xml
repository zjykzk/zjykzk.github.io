<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Os on 老K随笔</title>
    <link>http://zjykzk.github.io/tags/os/</link>
    <description>Recent content in Os on 老K随笔</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>(c) 2025 zenk.</copyright>
    <lastBuildDate>Wed, 16 Dec 2020 16:58:31 +0800</lastBuildDate>
    <atom:link href="http://zjykzk.github.io/tags/os/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>虚拟内存技术</title>
      <link>http://zjykzk.github.io/posts/cs/os/vm/</link>
      <pubDate>Wed, 16 Dec 2020 16:58:31 +0800</pubDate>
      <guid>http://zjykzk.github.io/posts/cs/os/vm/</guid>
      <description>&lt;h2 id=&#34;缘起&#34;&gt;缘起&lt;/h2&gt;&#xA;&lt;p&gt;最开始，操作系统的内存管理非常简陋。只是简单把物理内存分为两部分：低地址部分，64K分给操作系统，高地址部分分给用户程序。而且每次只执行一个程序。执行完后要重新装载程序，再执行其他程序。接着，由于那是机器非常昂贵，人们希望能够&lt;strong&gt;充分利用机器资源&lt;/strong&gt;。出现了&lt;strong&gt;多任务&lt;/strong&gt;的操作系统。这时操作系统能够支持一次自动执行多个任务，在某些程序执行IO的时候，CPU能够执行其他程序，这样就提升了机器资源的利用率。后来，又有了希望能够和程序&lt;strong&gt;及时交互&lt;/strong&gt;。这样就能方便知道程序执行的状态了，这个对程序员来说太重要了。不然，每次都要等程序执行完才能知道结果。于是有了&lt;strong&gt;分时&lt;/strong&gt;的操作系统，也就是每个进程执行一小部分时间。但是，这里就出现了安全问题，一个进程随意的读写另外一个进程的数据，甚至是操作系统的数据！由此，内存的虚拟化就出现了，它为每个程序提供一个统一抽象的&lt;strong&gt;地址空间&lt;/strong&gt;，程序看到的地址又叫&lt;strong&gt;虚拟地址&lt;/strong&gt;。它的目标包括：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;透明。对程序透明，每个程序只需要认知地址空间就行，不需要考虑自己的数据、代码是放在物理内存的哪个位置。&lt;/li&gt;&#xA;&lt;li&gt;高效。包括空间和时间两方面。&lt;/li&gt;&#xA;&lt;li&gt;安全。进程隔离，保证不能任意访问其他进程的数据。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;地址转换&#34;&gt;地址转换&lt;/h2&gt;&#xA;&lt;p&gt;简单来说，把进程的虚拟地址转换成物理地址。同时程序的每次内存访问都在操作系统的控制之下，确保安全。另外，通过硬件的支持保障性能以及地址转换对用户透明。&lt;strong&gt;它是内存虚拟化的核心机制，我们遇到的很多技术细节都是为了解决这个问题。&lt;/strong&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;策略&#34;&gt;策略&lt;/h3&gt;&#xA;&lt;h4 id=&#34;动态重定位&#34;&gt;动态重定位&lt;/h4&gt;&#xA;&lt;p&gt;这里包括软件实现的静态重定位(static relocation)和基于硬件的动态重定位(dynamic relocation)。&lt;/p&gt;&#xA;&lt;p&gt;软件的实现通过一个叫loader的软件，把应用程序中的引用的地址都加上一个偏移地址就变成物理地址了。显然，这里最大的问题是不安全。&lt;/p&gt;&#xA;&lt;p&gt;硬件就不一样了，它有两个寄存器一个基地址寄存器，一个地址范围限制寄存器。当访问一个内存的时候，先把地址加上基地址寄存器中的值，这个结果就是物理地址了。同时还会对比物理地址和地址范围寄存器比较，如果超过就触发异常。这个硬件一般叫做内存管理单元（&lt;strong&gt;MMU&lt;/strong&gt;）。&lt;/p&gt;&#xA;&lt;p&gt;因此，硬件需要提供以下几个功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;特权模式。因为硬件有MMU的操作指令，这些指令只有操作系统才能使用，用户程序是不能直接使用的。&lt;/li&gt;&#xA;&lt;li&gt;基地址寄存器和地址范围寄存器。用于虚拟地址到物理地址的转换以及地址合法性的检查。&lt;/li&gt;&#xA;&lt;li&gt;地址转换以及检查地址是否在范围内的能力。&lt;/li&gt;&#xA;&lt;li&gt;更新基地址寄存器和地址范围寄存器指令。操作系统运行一个进程时，需要把进程的基地址和地址范围设置到到相应的寄存器。&lt;/li&gt;&#xA;&lt;li&gt;提供特权指令注册异常处理程序。操作系统告诉硬件具体异常的处理程序地址。&lt;/li&gt;&#xA;&lt;li&gt;触发异常的能力。非法访问内存地址时触发异常。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;同时，操作系统需要提供以下几个功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;内存管理。为新进程分配内存，回收执行结束的进程使用的内存，通常是一个free list来管理。&lt;/li&gt;&#xA;&lt;li&gt;基地址和地址范围管理。进程切换时设置当前执行的进程的基地址和地址范围到相应的寄存器。&lt;/li&gt;&#xA;&lt;li&gt;异常处理能力。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;操作系统和硬件的交互，主要包含在启动和执行程序的时候。&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;启动&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;操作系统（kernel mode）                     硬件&#xA;================================+=================================&#xA; 初始化异常表&#xA;&#xA;                                       保存系统调用地址&#xA;                                       定时处理程序地址&#xA;                                       非法内存访问处理程序地址&#xA;                                       非法指令异常处理程序&#xA; 启动定时器中断&#xA;                                       开启定时器&#xA; 初始化进程表&#xA; 初始内存空闲列表&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;程序执行&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;操作系统（kernel mode）                           硬件                        程序（user mode）&#xA;================================+=======================================+=====================&#xA; 启动进程A：&#xA;  进程表中添加进程&#xA;  分配进程需要的内存&#xA;  设置基地址和地址范围寄存器&#xA;  执行进程A的代码&#xA;                                       恢复进程A的寄存器，进入user mode&#xA;                                       跳转到进程A的起始指令&#xA;                                                                              获取指令&#xA;                                       转换指令的物理地址，获取指令内容&#xA;                                                                              执行指令&#xA;                                       如果是保存或者获取数据，检查内存&#xA;                                       地址是否合法&#xA;                                                                              继续执行。。。&#xA;                                       定时器时间到了，进入kernel mode&#xA;                                       执行定时器处理程序&#xA; 停止执行进程A，保存进程A的上&#xA; 下文到进程控制块：&#xA;  当前执行的指令地址以及基地址&#xA;  寄存器和地址范围寄存器的值&#xA;  加载进程B的寄存器以及指令地址&#xA;  执行进程B的代码&#xA;                                       恢复进程B的寄存器，进入user mode&#xA;                                       跳转到进程B的指令&#xA;                                                                              访问非法地址&#xA;                                       地址越界，触发异常进入kernel mode&#xA; 执行非法访问地址异常代码，终止&#xA; 进程B，回收进程B的内存，释放&#xA; 进程表中有关进程B的内存&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;分段&#34;&gt;分段&lt;/h4&gt;&#xA;&lt;p&gt;把整个地址空间映射到物理空间如下图（假设地址空间大小是16K）：&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
