{"version":3,"file":"print.css","sources":["print.scss","_init.scss","../node_modules/breakpoint-sass/stylesheets/_breakpoint.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/_settings.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/_context.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/_helpers.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/_parsers.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_query.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_single.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/single/_default.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_double.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/double/_default-pair.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/double/_double-string.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/double/_default.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_triple.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/triple/_default.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/_resolution.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/parsers/resolution/_resolution.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/_no-query.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/_respond-to.scss","../node_modules/breakpoint-sass/stylesheets/breakpoint/_legacy-settings.scss","../node_modules/chroma-sass/sass/chroma/_functions.scss","../node_modules/chroma-sass/sass/chroma/_variables.scss","../node_modules/chroma-sass/sass/chroma/_internals.scss","../variables","init/_colors.scss","init/_variables.scss","../node_modules/chroma-sass/sass/_chroma.scss","../chroma/functions","../node_modules/chroma-sass/sass/chroma/_skin.scss","../functions","../node_modules/chroma-sass/sass/chroma/_kss.scss","../functions","../node_modules/typey/stylesheets/_typey.scss","../node_modules/typey/stylesheets/typey/functions/_helpers.scss","../node_modules/typey/stylesheets/typey/functions/_validators.scss","../node_modules/typey/stylesheets/typey/functions/_em-calculators.scss","../node_modules/typey/stylesheets/typey/functions/_outputters.scss","../node_modules/typey/stylesheets/typey/functions/_sizers.scss","../node_modules/typey/stylesheets/typey/functions/_extras.scss","../node_modules/typey/stylesheets/typey/functions/_depreciated.scss","../node_modules/typey/stylesheets/typey/_font-stacks.scss","../node_modules/typey/stylesheets/typey/_defaults.scss","../node_modules/typey/stylesheets/typey/mixins/_debug.scss","../node_modules/typey/stylesheets/typey/mixins/_define-type-sizing.scss","../node_modules/typey/stylesheets/typey/mixins/_font-size.scss","../node_modules/typey/stylesheets/typey/mixins/_line-height.scss","../node_modules/typey/stylesheets/typey/mixins/_spacing.scss","../node_modules/typey/stylesheets/typey/mixins/_typeface.scss","../node_modules/typey/stylesheets/typey/mixins/_typeset.scss","../node_modules/typey/stylesheets/typey/mixins/_type-layout.scss","init/clearfix/_clearfix.scss","init/rtl/_rtl.scss","init/visually-hidden/_visually-hidden.scss","init/image-url/_image-url.scss","components/print-none/_print-none.scss"],"sourcesContent":["// @file\n// The print stylesheet for this theme.\n\n// Colors and Sass\n//\n// Documentation for colors and Sass mixins and variables.\n//\n// Weight: -1\n\n@import 'init';\n\n// Components\n//\n// Weight: 1\n\n@import 'components/print-none/print-none';\n\n.pager,\n%pager,\naside,\nnav,\nfooter {\n  @extend %print-none;\n}\n\n@media print {\n  html {\n    font-size: $print-font-size;\n  }\n\n  body,\n  .page {\n    background-color: color(white);\n  }\n\n  [role='main'] {\n    width: 100%;\n  }\n\n  :link,\n  :visited {\n    text-decoration: underline;\n  }\n}\n","// Initialization partial\n//\n// To make it easier to use all variables and mixins in any Sass file in this\n// project, each .scss file has a `@import 'init';` declaration. The _init.scss\n// file is in charge of importing all the other partials needed for the\n// project.\n//\n// The initialization partial is organized in this way:\n// - First we set any shared Sass variables.\n// - Next we import Sass modules.\n// - Last we define our custom mixins for this project.\n//\n// Weight: -1\n//\n// Style guide: sass.init\n\n\n// The following Sass functions/mixins are required to generate some variables'\n// values, so we load them first.\n@import 'breakpoint';\n@import 'chroma/functions';\n\n@import 'init/colors';\n@import 'init/variables';\n\n\n// 3rd party libraries\n//\n// The following sass modules are shared with all .scss files:\n// - [Breakpoint](http://breakpoint-sass.com/)\n// - [Chroma](https://github.com/JohnAlbin/chroma)\n// - [Typey](https://github.com/jptaranto/typey)\n//\n// Additional pre-built libraries can be found on the [Sache website](http://www.sache.in/).\n//\n// Style guide: sass.modules\n\n// Add Chroma to manage colors.\n@import 'chroma';\n@import 'chroma/kss';\n// Add typey to manage font sizes and margins.\n@import 'typey';\n\n\n// Mixins\n//\n// Custom mixins used on this site.\n//\n// Weight: 1\n//\n// Style guide: sass.mixins\n@import 'init/clearfix/clearfix';\n@import 'init/rtl/rtl';\n@import 'init/visually-hidden/visually-hidden';\n\n// Functions\n//\n// Custom functions used on this site.\n//\n// Weight: 1\n//\n// Style guide: sass.functions\n@import 'init/image-url/image-url';\n","//////////////////////////////\n// Default Variables\n//////////////////////////////\n$Breakpoint-Settings: (\n  'default media': all,\n  'default feature': min-width,\n  'default pair': width,\n\n  'force all media type': false,\n  'to ems': false,\n  'transform resolutions': true,\n\n  'no queries': false,\n  'no query fallbacks': false,\n\n  'base font size': 16px,\n\n  'legacy syntax': false\n);\n\n$breakpoint: () !default;\n\n//////////////////////////////\n// Imports\n//////////////////////////////\n@import \"breakpoint/settings\";\n@import 'breakpoint/context';\n@import 'breakpoint/helpers';\n@import 'breakpoint/parsers';\n@import 'breakpoint/no-query';\n\n@import 'breakpoint/respond-to';\n\n@import \"breakpoint/legacy-settings\";\n\n//////////////////////////////\n// Breakpoint Mixin\n//////////////////////////////\n\n@mixin breakpoint($query, $no-query: false) {\n  @include legacy-settings-warning;\n\n  // Reset contexts\n  @include private-breakpoint-reset-contexts();\n\n  $breakpoint: breakpoint($query, false);\n\n  $query-string: map-get($breakpoint, 'query');\n  $query-fallback: map-get($breakpoint, 'fallback');\n\n  $private-breakpoint-context-holder: map-get($breakpoint, 'context holder') !global;\n  $private-breakpoint-query-count: map-get($breakpoint, 'query count') !global;\n\n  // Allow for an as-needed override or usage of no query fallback.\n  @if $no-query != false {\n    $query-fallback: $no-query;\n  }\n\n  @if $query-fallback != false {\n    $context-setter: private-breakpoint-set-context('no-query', $query-fallback);\n  }\n\n  // Print Out Query String\n  @if not breakpoint-get('no queries') {\n    @media #{$query-string} {\n      @content;\n    }\n  }\n\n  @if breakpoint-get('no query fallbacks') != false or breakpoint-get('no queries') == true {\n\n    $type: type-of(breakpoint-get('no query fallbacks'));\n    $print: false;\n\n    @if ($type == 'bool') {\n      $print: true;\n    }\n    @else if ($type == 'string') {\n      @if $query-fallback == breakpoint-get('no query fallbacks') {\n        $print: true;\n      }\n    }\n    @else if ($type == 'list') {\n      @each $wrapper in breakpoint-get('no query fallbacks') {\n        @if $query-fallback == $wrapper {\n          $print: true;\n        }\n      }\n    }\n\n    // Write Fallback\n    @if ($query-fallback != false) and ($print == true) {\n      $type-fallback: type-of($query-fallback);\n\n      @if ($type-fallback != 'bool') {\n        #{$query-fallback} & {\n          @content;\n        }\n      }\n      @else {\n        @content;\n      }\n    }\n  }\n\n  @include private-breakpoint-reset-contexts();\n}\n\n\n@mixin mq($query, $no-query: false) {\n  @include breakpoint($query, $no-query) {\n    @content;\n  }\n}\n","//////////////////////////////\n// Has Setting\n//////////////////////////////\n@function breakpoint-has($setting) {\n  @if map-has-key($breakpoint, $setting) {\n    @return true;\n  }\n  @else {\n    @return false;\n  }\n}\n\n//////////////////////////////\n// Get Settings\n//////////////////////////////\n@function breakpoint-get($setting) {\n  @if breakpoint-has($setting) {\n    @return map-get($breakpoint, $setting);\n  }\n  @else {\n    @return map-get($Breakpoint-Settings, $setting);\n  }\n}\n\n//////////////////////////////\n// Set Settings\n//////////////////////////////\n@function breakpoint-set($setting, $value) {\n  @if (str-index($setting, '-') or str-index($setting, '_')) and str-index($setting, ' ') == null {\n    @warn \"Words in Breakpoint settings should be separated by spaces, not dashes or underscores. Please replace dashes and underscores between words with spaces. Settings will not work as expected until changed.\";\n  }\n  $breakpoint: map-merge($breakpoint, ($setting: $value)) !global;\n  @return true;\n}\n\n@mixin breakpoint-change($setting, $value) {\n  $breakpoint-change: breakpoint-set($setting, $value);\n}\n\n@mixin breakpoint-set($setting, $value) {\n  @include breakpoint-change($setting, $value);\n}\n\n@mixin bkpt-change($setting, $value) {\n  @include breakpoint-change($setting, $value);\n}\n@mixin bkpt-set($setting, $value) {\n  @include breakpoint-change($setting, $value);\n}\n\n//////////////////////////////\n// Remove Setting\n//////////////////////////////\n@function breakpoint-reset($settings...) {\n  @if length($settings) == 1 {\n    $settings: nth($settings, 1);\n  }\n\n  @each $setting in $settings {\n    $breakpoint: map-remove($breakpoint, $setting) !global;\n  }\n  @return true;\n}\n\n@mixin breakpoint-reset($settings...) {\n  $breakpoint-reset: breakpoint-reset($settings);\n}\n\n@mixin bkpt-reset($settings...) {\n  $breakpoint-reset: breakpoint-reset($settings);\n}","//////////////////////////////\n// Private Breakpoint Variables\n//////////////////////////////\n$private-breakpoint-context-holder: ();\n$private-breakpoint-query-count: 0 !default;\n\n//////////////////////////////\n// Breakpoint Has Context\n// Returns whether or not you are inside a Breakpoint query\n//////////////////////////////\n@function breakpoint-has-context() {\n  @if length($private-breakpoint-query-count) {\n    @return true;\n  }\n  @else {\n    @return false;\n  }\n}\n\n//////////////////////////////\n// Breakpoint Get Context\n// $feature: Input feature to get it's current MQ context. Returns false if no context\n//////////////////////////////\n@function breakpoint-get-context($feature) {\n  @if map-has-key($private-breakpoint-context-holder, $feature) {\n    $get: map-get($private-breakpoint-context-holder, $feature);\n    // Special handling of no-query from get side so /false/ prepends aren't returned\n    @if $feature == 'no-query' {\n      @if type-of($get) == 'list' and length($get) > 1 and nth($get, 1) == false {\n        $get: nth($get, length($get));\n      }\n    }\n    @return $get;\n  }\n  @else {\n    @if breakpoint-has-context() and $feature == 'media' {\n      @return breakpoint-get('default media');\n    }\n    @else {\n      @return false;\n    }\n  }\n}\n\n//////////////////////////////\n// Private function to set context\n//////////////////////////////\n@function private-breakpoint-set-context($feature, $value) {\n  @if $value == 'monochrome' {\n    $feature: 'monochrome';\n  }\n\n  $current: map-get($private-breakpoint-context-holder, $feature);\n  @if $current and length($current) == $private-breakpoint-query-count {\n    @warn \"You have already queried against `#{$feature}`. Unexpected things may happen if you query against the same feature more than once in the same `and` query. Breakpoint is overwriting the current context with `#{$value}`\";\n  }\n\n  @if not map-has-key($private-breakpoint-context-holder, $feature) {\n    $v-holder: ();\n    @for $i from 1 to $private-breakpoint-query-count {\n      @if $feature == 'media' {\n        $v-holder: append($v-holder, breakpoint-get('default media'));\n      }\n      @else {\n        $v-holder: append($v-holder, false);\n      }\n    }\n    $v-holder: append($v-holder, $value);\n    $private-breakpoint-context-holder: map-merge($private-breakpoint-context-holder, ($feature: $v-holder)) !global;\n  }\n  @else {\n    $v-holder: map-get($private-breakpoint-context-holder, $feature);\n    $length: length($v-holder);\n    @for $i from $length to $private-breakpoint-query-count - 1 {\n      @if $feature == 'media' {\n        $v-holder: append($v-holder, breakpoint-get('default media'));\n      }\n      @else {\n        $v-holder: append($v-holder, false);\n      }\n    }\n    $v-holder: append($v-holder, $value);\n    $private-breakpoint-context-holder: map-merge($private-breakpoint-context-holder, ($feature: $v-holder)) !global;\n  }\n\n  @return true;\n}\n\n//////////////////////////////\n// Private function to reset context\n//////////////////////////////\n@mixin private-breakpoint-reset-contexts {\n  $private-breakpoint-context-holder: () !global;\n  $private-breakpoint-query-count: 0 !global;\n}","//////////////////////////////\n// Converts the input value to Base EMs\n//////////////////////////////\n@function breakpoint-to-base-em($value) {\n  $value-unit: unit($value);\n\n  // Will convert relative EMs into root EMs.\n  @if breakpoint-get('base font size') and type-of(breakpoint-get('base font size')) == 'number' and $value-unit == 'em' {\n    $base-unit: unit(breakpoint-get('base font size'));\n\n    @if $base-unit == 'px' or $base-unit == '%' or $base-unit == 'em' or $base-unit == 'pt' {\n      @return base-conversion($value) / base-conversion(breakpoint-get('base font size')) * 1em;\n    }\n    @else {\n      @warn '#{breakpoint-get(\\'base font size\\')} is not set in valid units for font size!';\n      @return false;\n    }\n  }\n  @else {\n    @return base-conversion($value);\n  }\n}\n\n@function base-conversion($value) {\n  $unit: unit($value);\n\n  @if $unit == 'px' {\n    @return $value / 16px * 1em;\n  }\n  @else if $unit == '%' {\n    @return $value / 100% * 1em;\n  }\n  @else if $unit == 'em' {\n    @return $value;\n  }\n  @else if $unit == 'pt' {\n    @return $value / 12pt * 1em;\n  }\n  @else {\n    @return $value;\n//    @warn 'Everything is terrible! What have you done?!';\n  }\n}\n\n//////////////////////////////\n// Returns whether the feature can have a min/max pair\n//////////////////////////////\n$breakpoint-min-max-features: 'color',\n                              'color-index',\n                              'aspect-ratio',\n                              'device-aspect-ratio',\n                              'device-height',\n                              'device-width',\n                              'height',\n                              'monochrome',\n                              'resolution',\n                              'width';\n\n@function breakpoint-min-max($feature) {\n  @each $item in $breakpoint-min-max-features {\n    @if $feature == $item {\n      @return true;\n    }\n  }\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature can have a string value\n//////////////////////////////\n$breakpoint-string-features:  'orientation',\n                              'scan',\n                              'color',\n                              'aspect-ratio',\n                              'device-aspect-ratio',\n                              'pointer',\n                              'luminosity';\n\n@function breakpoint-string-value($feature) {\n  @each $item in $breakpoint-string-features {\n    @if breakpoint-min-max($item) {\n      @if $feature == 'min-#{$item}' or $feature == 'max-#{$item}' {\n        @return true;\n      }\n    }\n    @else if $feature == $item {\n      @return true;\n    }\n  }\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature is a media type\n//////////////////////////////\n$breakpoint-media-types:  'all',\n                          'braille',\n                          'embossed',\n                          'handheld',\n                          'print',\n                          'projection',\n                          'screen',\n                          'speech',\n                          'tty',\n                          'tv';\n\n@function breakpoint-is-media($feature) {\n  @each $media in $breakpoint-media-types {\n    @if ($feature == $media) or ($feature == 'not #{$media}') or ($feature == 'only #{$media}') {\n      @return true;\n    }\n  }\n\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature can stand alone\n//////////////////////////////\n$breakpoint-single-string-features: 'color',\n                                    'color-index',\n                                    'grid',\n                                    'monochrome';\n\n@function breakpoint-single-string($feature) {\n  @each $item in $breakpoint-single-string-features {\n    @if $feature == $item {\n      @return true;\n    }\n  }\n  @return false;\n}\n\n//////////////////////////////\n// Returns whether the feature\n//////////////////////////////\n@function breakpoint-is-resolution($feature) {\n  $resolutions: 'device-pixel-ratio', 'dpr';\n\n  @if breakpoint-get('transform resolutions') {\n    $resolutions: append($resolutions, 'resolution');\n  }\n\n  @each $reso in $resolutions {\n    @if index($feature, $reso) or index($feature, 'min-#{$reso}') or index($feature, 'max-#{$reso}') {\n      @return true;\n    }\n  }\n\n  @return false;\n}\n","//////////////////////////////\n// Import Parser Pieces\n//////////////////////////////\n@import \"parsers/query\";\n@import \"parsers/single\";\n@import \"parsers/double\";\n@import \"parsers/triple\";\n@import \"parsers/resolution\";\n\n$Memo-Exists: function-exists(memo-get) and function-exists(memo-set);\n\n//////////////////////////////\n// Breakpoint Function\n//////////////////////////////\n@function breakpoint($query, $contexts...) {\n  $run: true;\n  $return: ();\n\n  // Grab the Memo Output if Memoization can be a thing\n  @if $Memo-Exists {\n    $return: memo-get(breakpoint, breakpoint $query $contexts);\n\n    @if $return != null {\n      $run: false;\n    }\n  }\n\n  @if not $Memo-Exists or $run {\n    // Internal Variables\n    $query-string: '';\n    $query-fallback: false;\n    $return: ();\n\n    // Reserve Global Private Breakpoint Context\n    $holder-context: $private-breakpoint-context-holder;\n    $holder-query-count: $private-breakpoint-query-count;\n\n    // Reset Global Private Breakpoint Context\n    $private-breakpoint-context-holder: () !global;\n    $private-breakpoint-query-count: 0 !global;\n\n\n    // Test to see if it's a comma-separated list\n    $or-list: if(list-separator($query) == 'comma', true, false);\n\n\n    @if ($or-list == false and breakpoint-get('legacy syntax') == false) {\n      $query-string: breakpoint-parse($query);\n    }\n    @else {\n      $length: length($query);\n\n      $last: nth($query, $length);\n      $query-fallback: breakpoint-no-query($last);\n\n      @if ($query-fallback != false) {\n        $length: $length - 1;\n      }\n\n      @if (breakpoint-get('legacy syntax') == true) {\n        $mq: ();\n\n        @for $i from 1 through $length {\n          $mq: append($mq, nth($query, $i), comma);\n        }\n\n        $query-string: breakpoint-parse($mq);\n      }\n      @else {\n        $query-string: '';\n        @for $i from 1 through $length {\n          $query-string: $query-string + if($i == 1, '', ', ') + breakpoint-parse(nth($query, $i));\n        }\n      }\n    }\n\n    $return: ('query': $query-string,\n        'fallback': $query-fallback,\n        'context holder': $private-breakpoint-context-holder,\n        'query count': $private-breakpoint-query-count\n    );\n    @if length($contexts) > 0 and nth($contexts, 1) != false {\n      @if $query-fallback != false {\n        $context-setter: private-breakpoint-set-context('no-query', $query-fallback);\n      }\n      $context-map: ();\n      @each $context in $contexts {\n        $context-map: map-merge($context-map, ($context: breakpoint-get-context($context)));\n      }\n      $return: map-merge($return, (context: $context-map));\n    }\n\n    // Reset Global Private Breakpoint Context\n    $private-breakpoint-context-holder: () !global;\n    $private-breakpoint-query-count: 0 !global;\n\n    @if $Memo-Exists {\n      $holder: memo-set(breakpoint, breakpoint $query $contexts, $return);\n    }\n  }\n\n  @return $return;\n}\n\n//////////////////////////////\n// General Breakpoint Parser\n//////////////////////////////\n@function breakpoint-parse($query) {\n  // Increase number of 'and' queries\n  $private-breakpoint-query-count: $private-breakpoint-query-count + 1 !global;\n\n  // Set up Media Type\n  $query-print: '';\n\n  $force-all: ((breakpoint-get('force all media type') == true) and (breakpoint-get('default media') == 'all'));\n  $empty-media: true;\n  @if ($force-all == true) or (breakpoint-get('default media') != 'all') {\n    // Force the print of the default media type if (force all is true and default media type is all) or (default media type is not all)\n    $query-print: breakpoint-get('default media');\n    $empty-media: false;\n  }\n\n\n  $query-resolution: false;\n\n  $query-holder: breakpoint-parse-query($query);\n\n\n\n  // Loop over each parsed out query and write it to $query-print\n  $first: true;\n\n  @each $feature in $query-holder {\n    $length: length($feature);\n\n    // Parse a single feature\n    @if ($length == 1) {\n      // Feature is currently a list, grab the actual value\n      $feature: nth($feature, 1);\n\n      // Media Type must by convention be the first item, so it's safe to flat override $query-print, which right now should only be the default media type\n      @if (breakpoint-is-media($feature)) {\n        @if ($force-all == true) or ($feature != 'all') {\n          // Force the print of the default media type if (force all is true and default media type is all) or (default media type is not all)\n          $query-print: $feature;\n          $empty-media: false;\n\n          // Set Context\n          $context-setter: private-breakpoint-set-context(media, $query-print);\n        }\n      }\n      @else {\n        $parsed: breakpoint-parse-single($feature, $empty-media, $first);\n        $query-print: '#{$query-print} #{$parsed}';\n        $first: false;\n      }\n    }\n    // Parse a double feature\n    @else if ($length == 2) {\n      @if (breakpoint-is-resolution($feature) != false) {\n        $query-resolution: $feature;\n      }\n      @else {\n        $parsed: null;\n        // If it's a string/number pair,\n        // we check to see if one is a single-string value,\n        // then we parse it as a normal double\n        $alpha: nth($feature, 1);\n        $beta: nth($feature, 2);\n        @if breakpoint-single-string($alpha) or breakpoint-single-string($beta) {\n          $parsed: breakpoint-parse-single($alpha, $empty-media, $first);\n          $query-print: '#{$query-print} #{$parsed}';\n          $first: false;\n          $parsed: breakpoint-parse-single($beta, $empty-media, $first);\n          $query-print: '#{$query-print} #{$parsed}';\n        }\n        @else {\n          $parsed: breakpoint-parse-double($feature, $empty-media, $first);\n          $query-print: '#{$query-print} #{$parsed}';\n          $first: false;\n        }\n      }\n    }\n    // Parse a triple feature\n    @else if ($length == 3) {\n      $parsed: breakpoint-parse-triple($feature, $empty-media, $first);\n      $query-print: '#{$query-print} #{$parsed}';\n      $first: false;\n    }\n\n  }\n\n  @if ($query-resolution != false) {\n    $query-print: breakpoint-build-resolution($query-print, $query-resolution, $empty-media, $first);\n  }\n\n  // Loop through each feature that's been detected so far and append 'false' to the the value list to increment their counters\n  @each $f, $v in $private-breakpoint-context-holder {\n    $v-holder: $v;\n    $length: length($v-holder);\n    @if length($v-holder) < $private-breakpoint-query-count {\n      @for $i from $length to $private-breakpoint-query-count {\n        @if $f == 'media' {\n          $v-holder: append($v-holder, breakpoint-get('default media'));\n        }\n        @else {\n          $v-holder: append($v-holder, false);\n        }\n      }\n    }\n    $private-breakpoint-context-holder: map-merge($private-breakpoint-context-holder, ($f: $v-holder)) !global;\n  }\n\n  @return $query-print;\n}\n","@function breakpoint-parse-query($query) {\n  // Parse features out of an individual query\n  $feature-holder: ();\n  $query-holder: ();\n  $length: length($query);\n\n  @if $length == 2 {\n    // If we've got a string/number, number/string, check to see if it's a valid string/number pair or two singles\n    @if (type-of(nth($query, 1)) == 'string' and type-of(nth($query, 2)) == 'number') or (type-of(nth($query, 1)) == 'number' and type-of(nth($query, 2)) == 'string') {\n\n      $number: '';\n      $value: '';\n\n      @if type-of(nth($query, 1)) == 'string' {\n        $number: nth($query, 2);\n        $value: nth($query, 1);\n      }\n      @else {\n        $number: nth($query, 1);\n        $value: nth($query, 2);\n      }\n\n      // If the string value can be a single value, check to see if the number passed in is a valid input for said single value. Fortunately, all current single-value options only accept unitless numbers, so this check is easy.\n      @if breakpoint-single-string($value) {\n        @if unitless($number) {\n          $feature-holder: append($value, $number, space);\n          $query-holder: append($query-holder, $feature-holder, comma);\n          @return $query-holder;\n        }\n      }\n      // If the string is a media type, split the query\n      @if breakpoint-is-media($value) {\n        $query-holder: append($query-holder, nth($query, 1));\n        $query-holder: append($query-holder, nth($query, 2));\n        @return $query-holder;\n      }\n      // If it's not a single feature, we're just going to assume it's a proper string/value pair, and roll with it.\n      @else {\n        $feature-holder: append($value, $number, space);\n        $query-holder: append($query-holder, $feature-holder, comma);\n        @return $query-holder;\n      }\n\n    }\n    // If they're both numbers, we assume it's a double and roll with that\n    @else if (type-of(nth($query, 1)) == 'number' and type-of(nth($query, 2)) == 'number') {\n      $feature-holder: append(nth($query, 1), nth($query, 2), space);\n      $query-holder: append($query-holder, $feature-holder, comma);\n      @return $query-holder;\n    }\n    // If they're both strings and neither are singles, we roll with that.\n    @else if (type-of(nth($query, 1)) == 'string' and type-of(nth($query, 2)) == 'string') {\n      @if not breakpoint-single-string(nth($query, 1)) and not breakpoint-single-string(nth($query, 2)) {\n        $feature-holder: append(nth($query, 1), nth($query, 2), space);\n        $query-holder: append($query-holder, $feature-holder, comma);\n        @return $query-holder;\n      }\n    }\n  }\n  @else if $length == 3 {\n    // If we've got three items and none is a list, we check to see\n    @if type-of(nth($query, 1)) != 'list' and type-of(nth($query, 2)) != 'list' and type-of(nth($query, 3)) != 'list' {\n      // If none of the items are single string values and none of the values are media values, we're good.\n      @if (not breakpoint-single-string(nth($query, 1)) and not breakpoint-single-string(nth($query, 2)) and not breakpoint-single-string(nth($query, 3))) and  ((not breakpoint-is-media(nth($query, 1)) and not breakpoint-is-media(nth($query, 2)) and not breakpoint-is-media(nth($query, 3)))) {\n        $feature-holder: append(nth($query, 1), nth($query, 2), space);\n        $feature-holder: append($feature-holder, nth($query, 3), space);\n        $query-holder: append($query-holder, $feature-holder, comma);\n        @return $query-holder;\n      }\n      // let's check to see if the first item is a media type\n      @else if breakpoint-is-media(nth($query, 1)) {\n        $query-holder: append($query-holder, nth($query, 1));\n        $feature-holder: append(nth($query, 2), nth($query, 3), space);\n        $query-holder: append($query-holder, $feature-holder);\n        @return $query-holder;\n      }\n    }\n  }\n\n  // If it's a single item, or if it's not a special case double or triple, we can simply return the query.\n  @return $query;\n}\n","//////////////////////////////\n// Import Pieces\n//////////////////////////////\n@import \"single/default\";\n\n@function breakpoint-parse-single($feature, $empty-media, $first) {\n  $parsed: '';\n  $leader: '';\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  // If it's a single feature that can stand alone, we let it\n  @if (breakpoint-single-string($feature)) {\n    $parsed: $feature;\n    // Set Context\n    $context-setter: private-breakpoint-set-context($feature, $feature);\n  }\n  // If it's not a stand alone feature, we pass it off to the default handler.\n  @else {\n    $parsed: breakpoint-parse-default($feature);\n  }\n\n  @return $leader + '(' + $parsed + ')';\n}\n","@function breakpoint-parse-default($feature) {\n  $default: breakpoint-get('default feature');\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context($default, $feature);\n\n  @if (breakpoint-get('to ems') == true) and (type-of($feature) == 'number') {\n    @return '#{$default}: #{breakpoint-to-base-em($feature)}';\n  }\n  @else {\n    @return '#{$default}: #{$feature}';\n  }\n}\n","//////////////////////////////\n// Import Pieces\n//////////////////////////////\n@import \"double/default-pair\";\n@import \"double/double-string\";\n@import \"double/default\";\n\n@function breakpoint-parse-double($feature, $empty-media, $first) {\n  $parsed: '';\n  $leader: '';\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  $first: nth($feature, 1);\n  $second: nth($feature, 2);\n\n  // If we've got two numbers, we know we need to use the default pair because there are no media queries that has a media feature that is a number\n  @if type-of($first) == 'number' and type-of($second) == 'number' {\n    $parsed: breakpoint-parse-default-pair($first, $second);\n  }\n  // If they are both strings, we send it through the string parser\n  @else if type-of($first) == 'string' and type-of($second) == 'string' {\n    $parsed: breakpoint-parse-double-string($first, $second);\n  }\n  // If it's a string/number pair, we parse it as a normal double\n  @else {\n    $parsed: breakpoint-parse-double-default($first, $second);\n  }\n\n  @return $leader + $parsed;\n}\n","@function breakpoint-parse-default-pair($first, $second) {\n  $default: breakpoint-get('default pair');\n  $min: '';\n  $max: '';\n\n  // Sort into min and max\n  $min: min($first, $second);\n  $max: max($first, $second);\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context(min-#{$default}, $min);\n  $context-setter: private-breakpoint-set-context(max-#{$default}, $max);\n\n  // Make them EMs if need be\n  @if (breakpoint-get('to ems') == true) {\n    $min: breakpoint-to-base-em($min);\n    $max: breakpoint-to-base-em($max);\n  }\n\n  @return '(min-#{$default}: #{$min}) and (max-#{$default}: #{$max})';\n}\n","@function breakpoint-parse-double-string($first, $second) {\n  $feature: '';\n  $value: '';\n\n  // Test to see which is the feature and which is the value\n  @if (breakpoint-string-value($first) == true) {\n    $feature: $first;\n    $value: $second;\n  }\n  @else if (breakpoint-string-value($second) == true) {\n    $feature: $second;\n    $value: $first;\n  }\n  @else {\n    @warn \"Neither #{$first} nor #{$second} is a valid media query name.\";\n  }\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context($feature, $value);\n\n  @return '(#{$feature}: #{$value})';\n}","@function breakpoint-parse-double-default($first, $second) {\n  $feature: '';\n  $value: '';\n\n  @if type-of($first) == 'string' {\n    $feature: $first;\n    $value: $second;\n  }\n  @else {\n    $feature: $second;\n    $value: $first;\n  }\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context($feature, $value);\n\n  @if (breakpoint-get('to ems') == true) {\n    $value: breakpoint-to-base-em($value);\n  }\n\n  @return '(#{$feature}: #{$value})'\n}\n","//////////////////////////////\n// Import Pieces\n//////////////////////////////\n@import \"triple/default\";\n\n@function breakpoint-parse-triple($feature, $empty-media, $first) {\n  $parsed: '';\n  $leader: '';\n\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  // separate the string features from the value numbers\n  $string: null;\n  $numbers: null;\n  @each $val in $feature {\n    @if type-of($val) == string {\n      $string: $val;\n    }\n    @else {\n      @if type-of($numbers) == 'null' {\n        $numbers: $val;\n      }\n      @else {\n        $numbers: append($numbers, $val);\n      }\n    }\n  }\n\n  $parsed: breakpoint-parse-triple-default($string, nth($numbers, 1), nth($numbers, 2));\n\n  @return $leader + $parsed;\n\n}\n","@function breakpoint-parse-triple-default($feature, $first, $second) {\n\n  // Sort into min and max\n  $min: min($first, $second);\n  $max: max($first, $second);\n\n  // Set Context\n  $context-setter: private-breakpoint-set-context(min-#{$feature}, $min);\n  $context-setter: private-breakpoint-set-context(max-#{$feature}, $max);\n\n  // Make them EMs if need be\n  @if (breakpoint-get('to ems') == true) {\n    $min: breakpoint-to-base-em($min);\n    $max: breakpoint-to-base-em($max);\n  }\n\n  @return '(min-#{$feature}: #{$min}) and (max-#{$feature}: #{$max})';\n}\n","@import \"resolution/resolution\";\n\n@function breakpoint-build-resolution($query-print, $query-resolution, $empty-media, $first) {\n  $leader: '';\n  // If we're forcing\n  @if not ($empty-media) or not ($first) {\n    $leader: 'and ';\n  }\n\n  @if breakpoint-get('transform resolutions') and $query-resolution {\n    $resolutions: breakpoint-make-resolutions($query-resolution);\n    $length: length($resolutions);\n    $query-holder: '';\n\n    @for $i from 1 through $length {\n      $query: '#{$query-print} #{$leader}#{nth($resolutions, $i)}';\n      @if $i == 1 {\n        $query-holder: $query;\n      }\n      @else {\n        $query-holder: '#{$query-holder}, #{$query}';\n      }\n    }\n\n    @return $query-holder;\n  }\n  @else {\n    // Return with attached resolution\n    @return $query-print;\n  }\n}\n","@function breakpoint-make-resolutions($resolution) {\n  $length: length($resolution);\n\n  $output: ();\n\n  @if $length == 2 {\n    $feature: '';\n    $value: '';\n\n    // Find which is number\n    @if type-of(nth($resolution, 1)) == 'number' {\n      $value: nth($resolution, 1);\n    }\n    @else {\n      $value: nth($resolution, 2);\n    }\n\n    // Determine min/max/standard\n    @if index($resolution, 'min-resolution') {\n      $feature: 'min-';\n    }\n    @else if index($resolution, 'max-resolution') {\n      $feature: 'max-';\n    }\n\n    $standard: '(#{$feature}resolution: #{$value})';\n\n    // If we're not dealing with dppx,\n    @if unit($value) != 'dppx' {\n      $base: 96dpi;\n      @if unit($value) == 'dpcm' {\n        $base: 243.84dpcm;\n      }\n      // Write out feature tests\n      $webkit: '';\n      $moz: '';\n      $webkit: '(-webkit-#{$feature}device-pixel-ratio: #{$value / $base})';\n      $moz: '(#{$feature}-moz-device-pixel-ratio: #{$value / $base})';\n      // Append to output\n      $output: append($output, $standard, space);\n      $output: append($output, $webkit, space);\n      $output: append($output, $moz, space);\n    }\n    @else {\n      $webkit: '';\n      $moz: '';\n      $webkit: '(-webkit-#{$feature}device-pixel-ratio: #{$value / 1dppx})';\n      $moz: '(#{$feature}-moz-device-pixel-ratio: #{$value / 1dppx})';\n      $fallback: '(#{$feature}resolution: #{$value / 1dppx * 96dpi})';\n      // Append to output\n      $output: append($output, $standard, space);\n      $output: append($output, $webkit, space);\n      $output: append($output, $moz, space);\n      $output: append($output, $fallback, space);\n    }\n\n  }\n\n  @return $output;\n}\n","@function breakpoint-no-query($query) {\n  @if type-of($query) == 'list' {\n    $keyword: nth($query, 1);\n\n    @if type-of($keyword) == 'string' and ($keyword == 'no-query' or $keyword == 'no query' or $keyword == 'fallback') {\n      @return nth($query, 2);\n    }\n    @else {\n      @return false;\n    }\n  }\n  @else {\n    @return false;\n  }\n}\n","////////////////////////\n// Default the Breakpoints variable\n////////////////////////\n$breakpoints: () !default;\n$BREAKPOINTS: () !default;\n\n////////////////////////\n// Respond-to API Mixin\n////////////////////////\n@mixin respond-to($context, $no-query: false) {\n  @if length($breakpoints) > 0 and length($BREAKPOINTS) == 0 {\n    @warn \"In order to avoid variable namespace collisions, we have updated the way to add breakpoints for respond-to. Please change all instances of `$breakpoints: add-breakpoint()` to `@include add-breakpoint()`. The `add-breakpoint()` function will be deprecated in a future release.\";\n    $BREAKPOINTS: $breakpoints !global;\n    $breakpoints: () !global;\n  }\n\n  @if type-of($BREAKPOINTS) != 'map' {\n    // Just in case someone writes gibberish to the $breakpoints variable.\n    @warn \"Your breakpoints aren't a map! `respond-to` expects a map. Please check the value of $BREAKPOINTS variable.\";\n    @content;\n  }\n  @else if map-has-key($BREAKPOINTS, $context) {\n    @include breakpoint(map-get($BREAKPOINTS, $context), $no-query) {\n      @content;\n    }\n  }\n  @else if not map-has-key($BREAKPOINTS, $context) {\n    @warn \"`#{$context}` isn't a defined breakpoint! Please add it using `$breakpoints: add-breakpoint(`#{$context}`, $value);`\";\n    @content;\n  }\n  @else {\n    @warn \"You haven't created any breakpoints yet! Make some already! `@include add-breakpoint($name, $bkpt)`\";\n    @content;\n  }\n}\n\n//////////////////////////////\n// Add Breakpoint to Breakpoints\n// TODO: Remove function in next release\n//////////////////////////////\n@function add-breakpoint($name, $bkpt, $overwrite: false) {\n  $output: ($name: $bkpt);\n\n  @if length($breakpoints) == 0 {\n    @return $output;\n  }\n  @else {\n    @if map-has-key($breakpoints, $name) and $overwrite != true {\n      @warn \"You already have a breakpoint named `#{$name}`, please choose another breakpoint name, or pass in `$overwrite: true` to overwrite the previous breakpoint.\";\n      @return $breakpoints;\n    }\n    @else if not map-has-key($breakpoints, $name) or $overwrite == true {\n      @return map-merge($breakpoints, $output);\n    }\n  }\n}\n\n@mixin add-breakpoint($name, $bkpt, $overwrite: false) {\n  $output: ($name: $bkpt);\n\n  @if length($BREAKPOINTS) == 0 {\n    $BREAKPOINTS: $output !global;\n  }\n  @else {\n    @if map-has-key($BREAKPOINTS, $name) and $overwrite != true {\n      @warn \"You already have a breakpoint named `#{$name}`, please choose another breakpoint name, or pass in `$overwrite: true` to overwrite the previous breakpoint.\";\n      $BREAKPOINTS: $BREAKPOINTS !global;\n    }\n    @else if not map-has-key($BREAKPOINTS, $name) or $overwrite == true {\n      $BREAKPOINTS: map-merge($BREAKPOINTS, $output) !global;\n    }\n  }\n}\n\n@function get-breakpoint($name: false) {\n  @if $name == false {\n    @return $BREAKPOINTS;\n  }\n  @else {\n    @return map-get($BREAKPOINTS, $name);\n  }\n}\n","@mixin legacy-settings-warning {\n  $legacyVars: (\n    'default-media': 'default media',\n    'default-feature': 'default feature',\n    'force-media-all': 'force all media type',\n    'to-ems': 'to ems',\n    'resolutions': 'transform resolutions',\n    'no-queries': 'no queries',\n    'no-query-fallbacks': 'no query fallbacks',\n    'base-font-size': 'base font size',\n    'legacy-syntax': 'legacy syntax'\n  );\n\n  @each $legacy, $new in $legacyVars {\n    @if global-variable-exists('breakpoint-' + $legacy) {\n      @warn \"In order to avoid variable namspace collisions, we have updated the way to change settings for Breakpoint. Please change all instances of `$breakpoint-#{$legacy}: {{setting}}` to `@include breakpoint-set('#{$new}', {{setting}})`. Variable settings, as well as this warning will be deprecated in a future release.\"\n    }\n  };\n\n  //////////////////////////////\n  // Hand correct each setting\n  //////////////////////////////\n  @if global-variable-exists('breakpoint-default-media') and $breakpoint-default-media != breakpoint-get('default media') {\n    @include breakpoint-set('default media', $breakpoint-default-media);\n  }\n  @if global-variable-exists('breakpoint-default-feature') and $breakpoint-default-feature != breakpoint-get('default feature') {\n    @include breakpoint-set('default feature', $breakpoint-default-feature);\n  }\n  @if global-variable-exists('breakpoint-force-media-all') and $breakpoint-force-media-all != breakpoint-get('force all media type') {\n    @include breakpoint-set('force all media type', $breakpoint-force-media-all);\n  }\n  @if global-variable-exists('breakpoint-to-ems') and $breakpoint-to-ems != breakpoint-get('to ems') {\n    @include breakpoint-set('to ems', $breakpoint-to-ems);\n  }\n  @if global-variable-exists('breakpoint-resolutions') and $breakpoint-resolutions != breakpoint-get('transform resolutions') {\n    @include breakpoint-set('transform resolutions', $breakpoint-resolutions);\n  }\n  @if global-variable-exists('breakpoint-no-queries') and $breakpoint-no-queries != breakpoint-get('no queries') {\n    @include breakpoint-set('no queries', $breakpoint-no-queries);\n  }\n  @if global-variable-exists('breakpoint-no-query-fallbacks') and $breakpoint-no-query-fallbacks != breakpoint-get('no query fallbacks') {\n    @include breakpoint-set('no query fallbacks', $breakpoint-no-query-fallbacks);\n  }\n  @if global-variable-exists('breakpoint-base-font-size') and $breakpoint-base-font-size != breakpoint-get('base font size') {\n    @include breakpoint-set('base font size', $breakpoint-base-font-size);\n  }\n  @if global-variable-exists('breakpoint-legacy-syntax') and $breakpoint-legacy-syntax != breakpoint-get('legacy syntax') {\n    @include breakpoint-set('legacy syntax', $breakpoint-legacy-syntax);\n  }\n}","// Functions module\n//\n// The main module for Chroma.\n//\n// Weight: -1\n//\n// Style guide: functions\n\n// Import the global variables and internal functions needed by all of Chroma.\n@import './variables';\n@import './internals';\n\n// Initialize the $chroma data structure.\n$chroma: _chroma-init();\n\n\n// is-dangerous-color-keyword($name)\n//\n// This function is used by color(), add-colors() and others to check if the\n// given color name is a \"dangerous\" color keyword. Returns false or causes the\n// Sass compilation to die with an error message containing the name of the\n// dangerous color keyword.\n//\n// If a real Sass color is given as a color name to Chroma, it is in danger of\n// being converted to a hexadecimal value before Chroma can read the name. (This\n// happens when Sass' \"compressed\" output style is used.) And some hex values\n// map to more than one keyword (e.g. gray/grey and fuchsia/magenta), so the\n// original name would be irretrievable.\n//\n// Since Chroma will confuse fuchsia and magenta (among others) under Sass'\n// \"compressed\" output style, it would generate confusing results. To prevent\n// this, Chroma halts Sass compilation when it detects an ambiguous color\n// keyword. While the error only occurs under Sass' \"compressed\" output style,\n// Chroma halts under all output styles. Otherwise, Chroma could behave\n// differently on production vs. development environments. If you are really\n// sure Chroma will never be run with Sass' \"compressed\" output style, you can\n// disable this feature by setting `$chroma-die-on-dangerous-keyword: false;`.\n//\n// $name - The name of the color to check.\n//\n// Style guide: functions.is-dangerous-color-keyword\n@function is-dangerous-color-keyword($name) {\n  // First, double-check if this is a keyword in a string.\n  @if _is-keyword-string($name) {\n    @return false;\n  }\n\n  @if type-of($name) == 'color' {\n    $lookup: '';\n    @if _is-old-libsass() {\n      // Forcibly convert a color keyword into a string with a \"salt\".\n      $lookup: \"keyword:#{$name}\";\n    }\n    @else {\n      // Convert the color to a string.\n      $lookup: inspect($name);\n    }\n    // Check if Sass will convert the color into a hex value that we can't\n    // convert back to a keyword.\n    @if map-has-key($_chroma-dangerous-keywords, $lookup) {\n      @if $chroma-die-on-dangerous-keyword {\n        @error \"Sass will convert #{$name} into a hexidecimal value when it uses the \\\"compressed\\\" output style and Chroma will not be able to determine if the original name was #{map-get($_chroma-dangerous-keywords, $lookup)}. To prevent this error, quote the keyword like this: '#{$name}'.\";\n      }\n      @else {\n        @return map-get($_chroma-dangerous-keywords, $lookup);\n      }\n    }\n    // Check if Sass _has_ converted the color into a hex value that we can't\n    // convert back to a keyword.\n    @else if map-has-key($_chroma-dangerous-converted-keywords, $lookup) {\n      @error \"Sass has converted a #{$_chroma-spelling} keyword into the hexidecimal value, #{$name}, and Chroma was not be able to determine if the original name was #{map-get($_chroma-dangerous-converted-keywords, $lookup)}. To prevent this error, use quotes around the keyword.\";\n    }\n  }\n  @return false;\n}\n\n// is-color-keyword($name)\n//\n// Checks if the given name is a color keyword. Returns false or a string\n// containing the name of the color keyword.\n//\n// $name - The name of the color to check.\n//\n// Style guide: functions.is-color-keyword\n@function is-color-keyword($name) {\n  // First, double-check if this is a keyword in a string.\n  @if _is-keyword-string($name) {\n    @return false;\n  }\n\n  // If a real Sass color is given, it is in danger of being converted to a\n  // hexadecimal value before we can read the name. And some hex values map to\n  // more than one keyword (e.g. gray and grey), so the original name would be\n  // irretrievable.\n  //\n  // While is-dangerous-color-keyword() would normally @error before it\n  // returned, if it does return a true value, we should continue inspecting\n  // $name so we can convert it to a string.\n  $is-dangerous: is-dangerous-color-keyword($name);\n\n  @if type-of($name) == 'color' {\n    $lookup: '';\n\n    @if _is-old-libsass() {\n      // Forcibly convert a color keyword into a string with a \"salt\".\n      $lookup: \"keyword:#{$name}\";\n    }\n    @else {\n      // Convert the color to a string.\n      $lookup: inspect($name);\n    }\n\n    @return if(map-has-key($_chroma-css4-color-keywords, $lookup), map-get($_chroma-css4-color-keywords, $lookup), false);\n  }\n\n  @return false;\n}\n\n// chroma-to-string($name)\n//\n// Cast the color name to a string to ensure color keywords do not cause\n// problems as map keys.\n//\n// $name - The name of the color to convert.\n//\n// Style guide: functions.chroma-to-string\n@function chroma-to-string($name) {\n  // If the name is a color keyword, is-color-keyword() converts it to a string.\n  $is-keyword: is-color-keyword($name);\n  @return if($is-keyword, $is-keyword, $name);\n}\n\n// color([$scheme,] $name)\n//\n// Returns a color value given a key word and optional color scheme. If the\n// named color is not in the color scheme, the color scheme's parent scheme will\n// be searched.\n//\n// Usage:\n// ```scss\n// .ex {\n//   background-color: color(body-bg);\n//   border: 1px solid color(grace, border);\n// }\n// ```\n//\n// $scheme - Optional color scheme to choose from; defaults to\n//           `$chroma-active-scheme`.\n// $name   - The name of the requested color.\n//\n// Style guide: functions.color\n@function color($scheme, $name: null) {\n  @if type-of($name) == 'null' {\n    // The shortcut syntax was used since $name is null. Move the color name to\n    // the $name parameter and set a default value to $scheme.\n    $name: $scheme;\n    $scheme: $chroma-active-scheme;\n  }\n\n  // Confirm the scheme exists.\n  @if not chroma-has-scheme($scheme) {\n    @error 'The #{$_chroma-spelling} scheme \"#{$scheme}\" was not found.';\n  }\n  // Cast the color name to a string to ensure color keywords do not cause\n  // problems as map keys.\n  $name: chroma-to-string($name);\n  // Find the actual scheme used by the named color.\n  $actual-scheme: chroma-has-color($name, $scheme);\n  @if not $actual-scheme {\n    @error 'The #{$_chroma-spelling} \"#{$name}\" was not found.';\n  }\n  $color: map-get(map-get($chroma, 'names'), \"#{$actual-scheme}::#{$name}\");\n  @if $actual-scheme == $scheme {\n    @return map-get($color, 'value');\n  }\n  @else {\n    // The value of $actual-scheme::$name is based on colors in $actual-scheme\n    // and its parent schemes. But one or more of the parent colors may be\n    // defined (overridden) in $scheme too, so we need to check the full\n    // reference chain.\n    $chain: ();\n    $ref: map-get($color, 'reference');\n    @if $ref and map-get($color, 'function') {\n      $chain: append($chain, $color);\n    }\n    @while $ref {\n      $actual-scheme: chroma-has-color($ref, $scheme);\n      $color: map-get(map-get($chroma, 'names'), \"#{$actual-scheme}::#{$ref}\");\n      $ref: map-get($color, 'reference');\n      // Save any color that has a function unless it is the final color in the\n      // reference chain.\n      @if $ref and map-get($color, 'function') {\n        $chain: append($chain, $color);\n      }\n    }\n    // Find the value for the last non-reference in the chain.\n    $value: map-get($color, 'value');\n    // If the reference chain contains functions, we need to recalculate all\n    // the values back up the chain.\n    @if length($chain) > 0 {\n      @for $i from length($chain) through 1 {\n        $function: map-get(nth($chain, $i), 'function');\n        $parameters: map-get(nth($chain, $i), 'parameters');\n        $parameters: set-nth($parameters, 1, $value);\n        $value: _safe-call($function, $parameters...);\n      }\n    }\n    @return $value;\n  }\n}\n\n// define-color-scheme($scheme [, $description] [, $parent])\n//\n// Define a new color scheme and, optionally, set its description and parent\n// color scheme.\n//\n// When searching for a color and the color scheme does not define that\n// particular color, the parent color scheme will be checked to see if it\n// defines that color.\n//\n// By default, all color schemes inherit their colors from the default color\n// scheme. Optionally, a color scheme can choose to inherit from a different\n// color scheme by specifying the `$parent` parameter.\n//\n// Usage:\n// ```scss\n// $chroma: define-color-scheme(taiwan, \"Taiwan's colors\");\n// $chroma: define-color-scheme(taipei, \"Taipei's colors\", $parent: taiwan);\n// ```\n//\n// $scheme      - The name of the new color scheme.\n// $description - Optional description of the color scheme.\n// $parent      - The parent color scheme to inherit colors from; defaults to\n//                `default` (i.e. `$CHROMA_DEFAULT_SCHEME`).\n//\n// Style guide: functions.define-color-scheme\n@function define-color-scheme($scheme, $description: '', $parent: $CHROMA_DEFAULT_SCHEME) {\n  // Check if we are defining the default color scheme.\n  @if $scheme == $CHROMA_DEFAULT_SCHEME {\n    $parent: false;\n  }\n\n  // Check parent reference exists.\n  @if $parent and not chroma-has-scheme($parent) {\n    @error 'Cannot set the parent of #{scheme} to \"#{$parent}\" because the #{$_chroma-spelling} scheme \"#{$parent}\" was not found.';\n  }\n\n  $schemes: map-merge(\n    map-get($chroma, 'schemes'),\n    ($scheme: (\n      'description': $description,\n      'parent': $parent,\n    ))\n  );\n\n  $chroma: map-merge(\n    $chroma,\n    ('schemes': $schemes)\n  ) !global;\n\n  @return $chroma;\n}\n\n// define-default-color-scheme([$name,] $description)\n//\n// Sets the description of the default color scheme.\n//\n// Usage:\n// ```scss\n// $chroma: define-default-color-scheme('Default colors');\n// // or:\n// $chroma: define-default-color-scheme('branding', 'Basic branding colors');\n// ```\n//\n// $name - Optional: default color scheme name; defaults to `default`.\n// $description - Description of the default color scheme.\n//\n// Style guide: functions.define-default-color-scheme\n@function define-default-color-scheme($name, $description: null) {\n  @if type-of($description) == 'null' {\n    // The shortcut syntax was used since $description is null. Move the actual\n    // description to the $description parameter.\n    $description: $name;\n    @return define-color-scheme($CHROMA_DEFAULT_SCHEME, $description);\n  }\n\n  // Remove the old default.\n  $schemes: map-remove(map-get($chroma, 'schemes'), $CHROMA_DEFAULT_SCHEME);\n  // Update all child schemes of the default.\n  @each $scheme-name, $map in $schemes {\n    @if map-get($map, 'parent') == $CHROMA_DEFAULT_SCHEME {\n      $schemes: map-merge(\n        $schemes,\n        ($scheme-name: (\n          'description': map-get($map, 'description'),\n          'parent': $name,\n        ))\n      );\n    }\n  }\n  // Set the new default scheme name and, if needed, the new active scheme.\n  @if $chroma-active-scheme == $CHROMA_DEFAULT_SCHEME {\n    $chroma-active-scheme: $name !global;\n  }\n  $CHROMA_DEFAULT_SCHEME: $name !global;\n  // Add the default scheme (and the updated schemes) back into $chroma.\n  $chroma: map-merge(\n    $chroma,\n    ('schemes': map-merge(\n      $schemes,\n      ($name: (\n        'description': $description,\n        'parent': false,\n      ))\n    ))\n  ) !global;\n\n  @return $chroma;\n}\n\n// add-colors([$scheme,] $colors)\n//\n// Add the colors to an existing color scheme.\n//\n// Usage:\n// ```scss\n// $chroma: add-colors('admiral', (\n//  link:        #0000cc,\n//  nav:         link, // Sets this color to the same value as the \"link\" color.\n//  nav-visited: (nav darken 20%), // Takes the \"nav\" color and passes it\n//                                 // through darken([color], 20%)\n//  nav-focus:   (nav lighten 10%),\n// ));\n// ```\n//\n// If you wish to add colors to the active scheme, you can just use:\n// ```scss\n// $chroma: add-colors((\n//  link:        #0000cc,\n//  nav:         link,\n//  nav-visited: (link darken 20%),\n//  nav-focus:   (link lighten 10%),\n// ));\n// ```\n//\n// $scheme - Optional: color scheme to add colors to; defaults to\n//           `$chroma-active-scheme`.\n// $colors - A Sass map containing the new colors.\n//\n// Style guide: functions.add-colors\n@function add-colors($scheme, $colors: null) {\n  @if type-of($scheme) == 'map' or type-of($scheme) == 'list' {\n    // The shortcut syntax was used since only a map of $colors was given as the\n    // first parameter. Move the map to the $colors parameter and set a default\n    // value to $scheme.\n    $colors: $scheme;\n    $scheme: $chroma-active-scheme;\n  }\n  @if not chroma-has-scheme($scheme) {\n    @error 'The #{$_chroma-spelling} scheme \"#{$scheme}\" was not found.';\n  }\n  @each $color-name, $color-value in $colors {\n    // Cast the color name to a string to ensure color keywords do not cause\n    // problems as map keys.\n    $color-name: chroma-to-string($color-name);\n    $color-function: false;\n    $color-parameters: ();\n    // If the \"value\" is a list, its a value plus a function.\n    @if type-of($color-value) == 'list' {\n      $color-function: nth($color-value, 2);\n      @if not function_exists($color-function) {\n        @error 'The function \"#{$color-function}\" was not found when adding the #{$_chroma-spelling} \"#{$color-name}\".';\n      }\n      // Include the color value in the list of function parameters.\n      @for $i from 1 through length($color-value) {\n        @if $i != 2 {\n          $color-parameters: append($color-parameters, nth($color-value, $i));\n        }\n      }\n      $color-value: nth($color-value, 1);\n    }\n    // If the value given is a color, just add it.\n    @if type-of($color-value) == 'color' and not (_is-old-libsass() and _is-keyword-string($color-value)) {\n      @if $color-function {\n        $color-value: _safe-call($color-function, $color-parameters...);\n      }\n      $chroma: _chroma-add-name($scheme, $color-name,\n        $value          : $color-value,\n        $reference      : false,\n        $referenced_by  : (),\n        $function       : $color-function,\n        $parameters     : $color-parameters\n      ) !global;\n    }\n    // If the value given is a reference to another color...\n    @else if type-of($color-value) == 'string' or (_is-old-libsass() and _is-keyword-string($color-value)) {\n      $ref: $color-value;\n      // Find the referenced color.\n      $scheme-of-reference: chroma-has-color($ref, $scheme);\n      @if not $scheme-of-reference {\n        @error 'The #{$_chroma-spelling} \"#{$ref}\" was not found when adding the #{$_chroma-spelling} \"#{$color-name}\".';\n      }\n      $referenced-color: map-get(map-get($chroma, 'names'), \"#{$scheme-of-reference}::#{$ref}\");\n      // Add the new color.\n      $new-value: map-get($referenced-color, 'value');\n      @if $color-function {\n        $color-parameters: set-nth($color-parameters, 1, $new-value);\n        $new-value: _safe-call($color-function, $color-parameters...);\n      }\n      $chroma: _chroma-add-name($scheme, $color-name,\n        $value         : $new-value,\n        $reference     : $ref,\n        $referenced_by : (),\n        $function      : $color-function,\n        $parameters    : $color-parameters\n      ) !global;\n      // Document the new color in all the referenced_by lists.\n      @while $ref {\n        $chroma: _chroma-add-name($scheme-of-reference, $ref,\n          $value         : map-get($referenced-color, 'value'),\n          $reference     : map-get($referenced-color, 'reference'),\n          $referenced_by : append(\n            map-get($referenced-color, 'referenced_by'),\n            $color-name\n          ),\n          $function      : map-get($referenced-color, 'function'),\n          $parameters    : map-get($referenced-color, 'parameters')\n        ) !global;\n        $ref: map-get($referenced-color, 'reference');\n        @if $ref {\n          $scheme-of-reference: chroma-has-color($ref, $scheme);\n          $referenced-color: map-get(map-get($chroma, 'names'), \"#{$scheme-of-reference}::#{$ref}\");\n        }\n      }\n    }\n    @else {\n      @error 'Unexpected value, \"#{$color-value}\", given for #{$_chroma-spelling} \"#{$color-name}\".';\n    }\n  }\n\n  @return $chroma;\n}\n\n// define-skins($skins)\n//\n// Defines one or more color schemes as being a skin. For each of the specified\n// color schemes, `define-skins()` will tell Chroma to use the scheme with the\n// corresponding CSS selector when the `skin()` mixin is used.\n//\n// Usage:\n// ```scss\n// $chroma: define-skins((\n//   'scheme1': '.is-scheme1-skin',\n//   'scheme2': '.is-scheme2-skin',\n//   'scheme3': 'html > body.this-works-but-is.way.too.specific.IMHO',\n// ));\n// ```\n//\n// $skins - A map of color schemes and their CSS parent selectors. Each key in\n// the map must be the name of an existing color scheme. The value of each key\n// is the CSS parent selector that triggers the use of the defined scheme\n// instead of the default color scheme. We recommend using a simple CSS selector\n// like `.is-CUSTOMNAME-skin`.\n//\n// Style guide: skin.define-skins\n@function define-skins($skins) {\n  @each $scheme, $selector in $skins {\n    @if not chroma-has-scheme($scheme) {\n      @error 'The #{$_chroma-spelling} scheme \"#{$scheme}\" was not found.';\n    }\n    @if type-of($selector) != 'string' {\n      @error 'The selector for the #{$scheme} skin was a #{type-of($selector)}, but should be a string.';\n    }\n  }\n\n  $chroma: map-merge(\n    $chroma,\n    ('skins': map-merge(\n      map-get($chroma, 'skins'),\n      $skins\n    ))\n  ) !global;\n\n  @return $chroma;\n}\n\n// define-skin($scheme, $selector)\n//\n// Deprecated: Will be removed in Chroma 2.0.0. Use `define-skins()` instead.\n//\n// Weight: 100\n//\n// Style guide: skin.define-skin\n@function define-skin($scheme, $selector) {\n  @warn \"The define-skin() function is deprecated. Use define-skins() instead.\";\n  @return define-skins(($scheme: $selector));\n}\n","// Variables module\n//\n// This module contains all the public and private variables needed for Chroma\n// to function. Only public variables are documented.\n//\n// Auto-imported by other modules.\n//\n// Weight: -2\n//\n// Style guide: variables\n\n//\n// Public variables.\n//\n\n// $chroma\n//\n// The colors and meta-data managed by Chroma.\n//\n// Chroma stores all of its colors, color schemes, skins etc. in the global\n// sass variable, `$chroma`. All of Chroma's configuration functions are\n// designed to save their changes to the system by changing the value of the\n// `$chroma` variable. For example: `$chroma: add-colors((kermit, #70af00));`\n//\n// Note: since the `$chroma` variable is a complex map of data structures, it\n// is highly recommended to only access `$chroma` through the functions and\n// mixins provided and not attempt to read data from `$chroma` with Sass'\n// `map-get()` and `map-set()` functions. (If you find you need more helper\n// functions, submit a feature request! We're happy to help.)\n//\n// Style guide: variables.chroma\n$chroma: () !default;\n\n// $CHROMA_DEFAULT_SCHEME\n//\n// The name of the default color scheme; defaults to `default`. This variable\n// is READ ONLY; changing its value will break Chroma.\n//\n// If you want to change this variable's value, you must use the\n// `define-default-color-scheme()` function instead.\n//\n// Style guide: variables.CHROMA_DEFAULT_SCHEME\n$CHROMA_DEFAULT_SCHEME: 'default';\n\n// $chroma-active-scheme\n//\n// The currently active color scheme. This is the default value used by the\n// $scheme parameter of most Chroma functions.\n//\n// By default, this variable is set to the 'default' color scheme.\n//\n// Style guide: variables.chroma-active-scheme\n$chroma-active-scheme: $CHROMA_DEFAULT_SCHEME !default;\n\n// $chroma-die-on-dangerous-keyword\n//\n// Controls whether Chroma will halt Sass compilation if it encounters a\n// \"dangerous color keyword\".\n//\n// See the docs of is-dangerous-color-keyword() for more information.\n//\n// Style guide: variables.chroma-die-on-dangerous-keyword\n$chroma-die-on-dangerous-keyword: true !default;\n\n//\n// Private variables.\n//\n\n// Let the Aussies, etc. have their preferred spelling.\n//\n// Rather than setting this variable directly, users should import the colour\n// module with: `@import 'chroma/colour';`\n$_chroma-spelling: 'color' !default;\n\n// The following keywords will cause confusion if used as color names. See the\n// docs of is-dangerous-color-keyword() for more information.\n$_chroma-dangerous-keywords: (\n  'aqua': 'aqua or cyan',\n  'cyan': 'aqua or cyan',\n  'fuchsia': 'fuchsia or magenta',\n  'magenta': 'fuchsia or magenta',\n  'darkgray': 'darkgray or darkgrey',\n  'darkgrey': 'darkgray or darkgrey',\n  'darkslategray': 'darkslategray or darkslategrey',\n  'darkslategrey': 'darkslategray or darkslategrey',\n  'dimgray': 'dimgray or dimgrey',\n  'dimgrey': 'dimgray or dimgrey',\n  'gray': 'gray or grey',\n  'grey': 'gray or grey',\n  'lightgray': 'lightgray or lightgrey',\n  'lightgrey': 'lightgray or lightgrey',\n  'lightslategray': 'lightslategray or lightslategrey',\n  'lightslategrey': 'lightslategray or lightslategrey',\n  'slategray': 'slategray or slategrey',\n  'slategrey': 'slategray or slategrey',\n);\n\n// The following color values are the converted values of dangerous color\n// keywords. If Chroma sees these values as color names, it means Sass converted\n// the original color name before Chroma could see it. See the docs of\n// is-dangerous-color-keyword() for more information.\n$_chroma-dangerous-converted-keywords: (\n  '#00ffff': 'aqua or cyan',\n  '#0ff': 'aqua or cyan',\n  '#ff00ff': 'fuchsia or magenta',\n  '#f0f': 'fuchsia or magenta',\n  '#a9a9a9': 'darkgray or darkgrey',\n  '#2f4f4f': 'darkslategray or darkslategrey',\n  '#696969': 'dimgray or dimgrey',\n  '#808080': 'gray or grey',\n  '#d3d3d3': 'lightgray or lightgrey',\n  '#778899': 'lightslategray or lightslategrey',\n  '#789': 'lightslategray or lightslategrey',\n  '#708090': 'slategray or slategrey',\n);\n\n// We need to identify color names that are also color keywords so we can safely\n// convert them to strings. Hex values are also included in the list since Sass\n// may convert keywords to hex before Chroma can see them; this allows us to\n// safely convert them back.\n//\n// This is the full list of CSS4 color keywords including the dangerous ones.\n// From http://dev.w3.org/csswg/css-color-4/#named-colors\n$_chroma-css4-color-keywords: (\n  'aliceblue': 'aliceblue',\n  '#f0f8ff': 'aliceblue',\n  'antiquewhite': 'antiquewhite',\n  '#faebd7': 'antiquewhite',\n  'aqua': 'aqua',\n  'aquamarine': 'aquamarine',\n  '#7fffd4': 'aquamarine',\n  'azure': 'azure',\n  '#f0ffff': 'azure',\n  'beige': 'beige',\n  '#f5f5dc': 'beige',\n  'bisque': 'bisque',\n  '#ffe4c4': 'bisque',\n  'black': 'black',\n  '#000000': 'black',\n  '#000': 'black',\n  'blanchedalmond': 'blanchedalmond',\n  '#ffebcd': 'blanchedalmond',\n  'blue': 'blue',\n  '#0000ff': 'blue',\n  '#00f': 'blue',\n  'blueviolet': 'blueviolet',\n  '#8a2be2': 'blueviolet',\n  'brown': 'brown',\n  '#a52a2a': 'brown',\n  'burlywood': 'burlywood',\n  '#deb887': 'burlywood',\n  'cadetblue': 'cadetblue',\n  '#5f9ea0': 'cadetblue',\n  'chartreuse': 'chartreuse',\n  '#7fff00': 'chartreuse',\n  'chocolate': 'chocolate',\n  '#d2691e': 'chocolate',\n  'coral': 'coral',\n  '#ff7f50': 'coral',\n  'cornflowerblue': 'cornflowerblue',\n  '#6495ed': 'cornflowerblue',\n  'cornsilk': 'cornsilk',\n  '#fff8dc': 'cornsilk',\n  'crimson': 'crimson',\n  '#dc143c': 'crimson',\n  'cyan': 'cyan',\n  '#00ffff': 'cyan',\n  '#0ff': 'cyan',\n  'darkblue': 'darkblue',\n  '#00008b': 'darkblue',\n  'darkcyan': 'darkcyan',\n  '#008b8b': 'darkcyan',\n  'darkgoldenrod': 'darkgoldenrod',\n  '#b8860b': 'darkgoldenrod',\n  'darkgray': 'darkgray',\n  '#a9a9a9': 'darkgray',\n  'darkgreen': 'darkgreen',\n  '#006400': 'darkgreen',\n  'darkgrey': 'darkgrey',\n  'darkkhaki': 'darkkhaki',\n  '#bdb76b': 'darkkhaki',\n  'darkmagenta': 'darkmagenta',\n  '#8b008b': 'darkmagenta',\n  'darkolivegreen': 'darkolivegreen',\n  '#556b2f': 'darkolivegreen',\n  'darkorange': 'darkorange',\n  '#ff8c00': 'darkorange',\n  'darkorchid': 'darkorchid',\n  '#9932cc': 'darkorchid',\n  'darkred': 'darkred',\n  '#8b0000': 'darkred',\n  'darksalmon': 'darksalmon',\n  '#e9967a': 'darksalmon',\n  'darkseagreen': 'darkseagreen',\n  '#8fbc8f': 'darkseagreen',\n  'darkslateblue': 'darkslateblue',\n  '#483d8b': 'darkslateblue',\n  'darkslategray': 'darkslategray',\n  '#2f4f4f': 'darkslategray',\n  'darkslategrey': 'darkslategrey',\n  'darkturquoise': 'darkturquoise',\n  '#00ced1': 'darkturquoise',\n  'darkviolet': 'darkviolet',\n  '#9400d3': 'darkviolet',\n  'deeppink': 'deeppink',\n  '#ff1493': 'deeppink',\n  'deepskyblue': 'deepskyblue',\n  '#00bfff': 'deepskyblue',\n  'dimgray': 'dimgray',\n  '#696969': 'dimgray',\n  'dimgrey': 'dimgrey',\n  'dodgerblue': 'dodgerblue',\n  '#1e90ff': 'dodgerblue',\n  'firebrick': 'firebrick',\n  '#b22222': 'firebrick',\n  'floralwhite': 'floralwhite',\n  '#fffaf0': 'floralwhite',\n  'forestgreen': 'forestgreen',\n  '#228b22': 'forestgreen',\n  'fuchsia': 'fuchsia',\n  'gainsboro': 'gainsboro',\n  '#dcdcdc': 'gainsboro',\n  'ghostwhite': 'ghostwhite',\n  '#f8f8ff': 'ghostwhite',\n  'gold': 'gold',\n  '#ffd700': 'gold',\n  'goldenrod': 'goldenrod',\n  '#daa520': 'goldenrod',\n  'gray': 'gray',\n  '#808080': 'gray',\n  'green': 'green',\n  '#008000': 'green',\n  'greenyellow': 'greenyellow',\n  '#adff2f': 'greenyellow',\n  'grey': 'grey',\n  'honeydew': 'honeydew',\n  '#f0fff0': 'honeydew',\n  'hotpink': 'hotpink',\n  '#ff69b4': 'hotpink',\n  'indianred': 'indianred',\n  '#cd5c5c': 'indianred',\n  'indigo': 'indigo',\n  '#4b0082': 'indigo',\n  'ivory': 'ivory',\n  '#fffff0': 'ivory',\n  'khaki': 'khaki',\n  '#f0e68c': 'khaki',\n  'lavender': 'lavender',\n  '#e6e6fa': 'lavender',\n  'lavenderblush': 'lavenderblush',\n  '#fff0f5': 'lavenderblush',\n  'lawngreen': 'lawngreen',\n  '#7cfc00': 'lawngreen',\n  'lemonchiffon': 'lemonchiffon',\n  '#fffacd': 'lemonchiffon',\n  'lightblue': 'lightblue',\n  '#add8e6': 'lightblue',\n  'lightcoral': 'lightcoral',\n  '#f08080': 'lightcoral',\n  'lightcyan': 'lightcyan',\n  '#e0ffff': 'lightcyan',\n  'lightgoldenrodyellow': 'lightgoldenrodyellow',\n  '#fafad2': 'lightgoldenrodyellow',\n  'lightgray': 'lightgray',\n  '#d3d3d3': 'lightgray',\n  'lightgreen': 'lightgreen',\n  '#90ee90': 'lightgreen',\n  'lightgrey': 'lightgrey',\n  'lightpink': 'lightpink',\n  '#ffb6c1': 'lightpink',\n  'lightsalmon': 'lightsalmon',\n  '#ffa07a': 'lightsalmon',\n  'lightseagreen': 'lightseagreen',\n  '#20b2aa': 'lightseagreen',\n  'lightskyblue': 'lightskyblue',\n  '#87cefa': 'lightskyblue',\n  'lightslategray': 'lightslategray',\n  '#778899': 'lightslategray',\n  '#789': 'lightslategray',\n  'lightslategrey': 'lightslategrey',\n  'lightsteelblue': 'lightsteelblue',\n  '#b0c4de': 'lightsteelblue',\n  'lightyellow': 'lightyellow',\n  '#ffffe0': 'lightyellow',\n  'lime': 'lime',\n  '#00ff00': 'lime',\n  '#0f0': 'lime',\n  'limegreen': 'limegreen',\n  '#32cd32': 'limegreen',\n  'linen': 'linen',\n  '#faf0e6': 'linen',\n  'magenta': 'magenta',\n  '#ff00ff': 'magenta',\n  '#f0f': 'magenta',\n  'maroon': 'maroon',\n  '#800000': 'maroon',\n  'mediumaquamarine': 'mediumaquamarine',\n  '#66cdaa': 'mediumaquamarine',\n  'mediumblue': 'mediumblue',\n  '#0000cd': 'mediumblue',\n  'mediumorchid': 'mediumorchid',\n  '#ba55d3': 'mediumorchid',\n  'mediumpurple': 'mediumpurple',\n  '#9370db': 'mediumpurple',\n  'mediumseagreen': 'mediumseagreen',\n  '#3cb371': 'mediumseagreen',\n  'mediumslateblue': 'mediumslateblue',\n  '#7b68ee': 'mediumslateblue',\n  'mediumspringgreen': 'mediumspringgreen',\n  '#00fa9a': 'mediumspringgreen',\n  'mediumturquoise': 'mediumturquoise',\n  '#48d1cc': 'mediumturquoise',\n  'mediumvioletred': 'mediumvioletred',\n  '#c71585': 'mediumvioletred',\n  'midnightblue': 'midnightblue',\n  '#191970': 'midnightblue',\n  'mintcream': 'mintcream',\n  '#f5fffa': 'mintcream',\n  'mistyrose': 'mistyrose',\n  '#ffe4e1': 'mistyrose',\n  'moccasin': 'moccasin',\n  '#ffe4b5': 'moccasin',\n  'navajowhite': 'navajowhite',\n  '#ffdead': 'navajowhite',\n  'navy': 'navy',\n  '#000080': 'navy',\n  'oldlace': 'oldlace',\n  '#fdf5e6': 'oldlace',\n  'olive': 'olive',\n  '#808000': 'olive',\n  'olivedrab': 'olivedrab',\n  '#6b8e23': 'olivedrab',\n  'orange': 'orange',\n  '#ffa500': 'orange',\n  'orangered': 'orangered',\n  '#ff4500': 'orangered',\n  'orchid': 'orchid',\n  '#da70d6': 'orchid',\n  'palegoldenrod': 'palegoldenrod',\n  '#eee8aa': 'palegoldenrod',\n  'palegreen': 'palegreen',\n  '#98fb98': 'palegreen',\n  'paleturquoise': 'paleturquoise',\n  '#afeeee': 'paleturquoise',\n  'palevioletred': 'palevioletred',\n  '#db7093': 'palevioletred',\n  'papayawhip': 'papayawhip',\n  '#ffefd5': 'papayawhip',\n  'peachpuff': 'peachpuff',\n  '#ffdab9': 'peachpuff',\n  'peru': 'peru',\n  '#cd853f': 'peru',\n  'pink': 'pink',\n  '#ffc0cb': 'pink',\n  'plum': 'plum',\n  '#dda0dd': 'plum',\n  'powderblue': 'powderblue',\n  '#b0e0e6': 'powderblue',\n  'purple': 'purple',\n  '#800080': 'purple',\n  'rebeccapurple': 'rebeccapurple',\n  '#663399': 'rebeccapurple',\n  'red': 'red',\n  '#ff0000': 'red',\n  '#f00': 'red',\n  'rosybrown': 'rosybrown',\n  '#bc8f8f': 'rosybrown',\n  'royalblue': 'royalblue',\n  '#4169e1': 'royalblue',\n  'saddlebrown': 'saddlebrown',\n  '#8b4513': 'saddlebrown',\n  'salmon': 'salmon',\n  '#fa8072': 'salmon',\n  'sandybrown': 'sandybrown',\n  '#f4a460': 'sandybrown',\n  'seagreen': 'seagreen',\n  '#2e8b57': 'seagreen',\n  'seashell': 'seashell',\n  '#fff5ee': 'seashell',\n  'sienna': 'sienna',\n  '#a0522d': 'sienna',\n  'silver': 'silver',\n  '#c0c0c0': 'silver',\n  'skyblue': 'skyblue',\n  '#87ceeb': 'skyblue',\n  'slateblue': 'slateblue',\n  '#6a5acd': 'slateblue',\n  'slategray': 'slategray',\n  '#708090': 'slategray',\n  'slategrey': 'slategrey',\n  'snow': 'snow',\n  '#fffafa': 'snow',\n  'springgreen': 'springgreen',\n  '#00ff7f': 'springgreen',\n  'steelblue': 'steelblue',\n  '#4682b4': 'steelblue',\n  'tan': 'tan',\n  '#d2b48c': 'tan',\n  'teal': 'teal',\n  '#008080': 'teal',\n  'thistle': 'thistle',\n  '#d8bfd8': 'thistle',\n  'tomato': 'tomato',\n  '#ff6347': 'tomato',\n  'turquoise': 'turquoise',\n  '#40e0d0': 'turquoise',\n  'violet': 'violet',\n  '#ee82ee': 'violet',\n  'wheat': 'wheat',\n  '#f5deb3': 'wheat',\n  'white': 'white',\n  '#ffffff': 'white',\n  '#fff': 'white',\n  'whitesmoke': 'whitesmoke',\n  '#f5f5f5': 'whitesmoke',\n  'yellow': 'yellow',\n  '#ffff00': 'yellow',\n  '#ff0': 'yellow',\n  'yellowgreen': 'yellowgreen',\n  '#9acd32': 'yellowgreen',\n);\n\n// libsass before 3.3.0 can't turn color keywords into strings of the same name,\n// so we have to compare map keys using keywords plus a \"salt\" string.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n\n$_chroma-css4-color-keywords-in-strings: ();\n@if type-of('white') == 'color' {\n  // Convert the dangerous color keyword list.\n  $_new-list: ();\n  @each $name, $string in $_chroma-dangerous-keywords {\n    $_new-list: map-merge($_new-list, (\"keyword:#{$name}\": $string));\n  }\n  $_chroma-dangerous-keywords: $_new-list !global;\n\n  // Convert the dangerous converted color keyword list.\n  $_new-list: ();\n  @each $name, $string in $_chroma-dangerous-converted-keywords {\n    $_new-list: map-merge($_new-list, (\"keyword:#{$name}\": $string));\n  }\n  $_chroma-dangerous-converted-keywords: $_new-list !global;\n\n  // Convert the css4 color keyword list, but keep a copy around to check for\n  // color keywords in strings.\n  $_chroma-css4-color-keywords-in-strings: $_chroma-css4-color-keywords !global;\n  $_new-list: ();\n  @each $name, $string in $_chroma-css4-color-keywords {\n    $_new-list: map-merge($_new-list, (\"keyword:#{$name}\": $string));\n  }\n  $_chroma-css4-color-keywords: $_new-list !global;\n}\n","// Internals\n//\n// Helper functions that query the internal data structure in $chroma. These are\n// not part of the public API and are subject to change at any time.\n//\n// Weight: 10\n//\n// Style guide: internals\n\n// Import the global variables needed by all of Chroma.\n@import './variables';\n\n// chroma-has-scheme($scheme)\n//\n// Checks if the named color scheme exists.\n//\n// Style guide: internals.chroma-has-scheme\n@function chroma-has-scheme($scheme) {\n  @return map-has-key(map-get($chroma, 'schemes'), $scheme);\n}\n\n// chroma-schemes()\n//\n// Returns a list of all color schemes in $chroma.\n//\n// Style guide: internals.chroma-schemes\n@function chroma-schemes() {\n  @return map-keys(map-get($chroma, 'schemes'));\n}\n\n// chroma-has-color($name [, $scheme])\n//\n// Checks if the named color exists in the given scheme or its parent schemes.\n// Returns false or a string of the scheme name that contains the color.\n//\n// Style guide: internals.chroma-has-color\n@function chroma-has-color($name, $scheme: $chroma-active-scheme) {\n  $current-scheme: $scheme;\n  @while $current-scheme {\n    @if map-has-key(map-get($chroma, 'names'), \"#{$current-scheme}::#{$name}\") {\n      @return $current-scheme;\n    }\n    // Look in the parent scheme.\n    $current-scheme: map-get(map-get(map-get($chroma, 'schemes'), $current-scheme), 'parent');\n  }\n  @return false;\n}\n\n// _chroma-add-name()\n//\n// Private function that adds a color to the data structure of the $chroma\n// variable.\n//\n// Style guide: internals._chroma-add-name\n@function _chroma-add-name($scheme, $name, $value: false, $reference: false, $referenced_by: (), $function: false, $parameters: ()) {\n  $names: map-merge(\n    map-get($chroma, 'names'),\n    (\"#{$scheme}::#{$name}\": (\n      value         : $value,\n      reference     : $reference,\n      referenced_by : $referenced_by,\n      function      : $function,\n      parameters    : $parameters,\n    ))\n  );\n\n  @return map-merge(\n    $chroma,\n    ('names': $names)\n  );\n}\n\n// _chroma-init()\n//\n// Private function that sets up the initial data structure of the $chroma\n// variable. Can be called repeatedly without damaging existing data.\n//\n// Style guide: internals._chroma-init\n@function _chroma-init() {\n  @if length($chroma) == 0 {\n    @return (\n      'schemes': (\n        $CHROMA_DEFAULT_SCHEME : (\n          'description': '',\n          'parent': false,\n        ),\n      ),\n      'skins': (),\n      'names': (),\n    );\n  }\n  @else {\n    @return $chroma;\n  }\n}\n\n// is-old-libsass()\n//\n// libsass before 3.3.0 is funky, making it very hard for Chroma to do its job.\n//\n// - `inspect([color])` returns the original value instead of returning the\n//   string equivalent, so you can't cast a color to a string.\n// - `type-of('[color keyword]')` thinks that these strings are colors.\n// - `map-has-key()` works properly, thankfully. So:\n//   - `map-has-key((white: ''), white)` correctly returns `true`\n//   - `map-has-key(('white': ''), 'white')` correctly returns `true`\n//   - `map-has-key((white: ''), 'white')` correctly returns `false`\n//   - `map-has-key(('white': ''), white)` correctly returns `false`\n//   This means we can cobble together a replacement for `type-of()`. And a\n//   partial replacement for `inspect()` that works for everything except\n//   dangerous color keywords.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n//\n// Style guide: internals._is-old-libsass\n@function _is-old-libsass() {\n  @return if(type-of('white') == 'color', true, false);\n}\n\n// _is-keyword-string($name)\n//\n// Normally, `type-of()` can be used to tell if a given value is a string. But\n// LibSass versions before 3.3.0 think that color keywords in strings are still\n// colors and not strings. This function works, regardless of LibSass bugs.\n//\n// @TODO: Remove when LibSass 3.2.5 support is dropped.\n//\n// Style guide: internals._is-keyword-string\n@function _is-keyword-string($name) {\n  @return if(map-has-key($_chroma-css4-color-keywords-in-strings, $name), true, false);\n}\n\n// _safe-call()\n//\n// LibSass incorrectly throws an error when using the variable argument\n// indicator, ..., with an overloaded function; e.g. rgba(). To work-around this\n// bug, we call rgba() with direct parameters.\n//\n// @TODO: Remove when the fix for https://github.com/sass/libsass/issues/2205 is released.\n//\n// Style guide: internals._safe-call\n@function _safe-call($function, $parameters...) {\n  @if $function == rgba {\n    @return rgba(nth($parameters, 1), nth($parameters, 2));\n  }\n  @return call($function, $parameters...);\n}\n","","// sass-lint:disable indentation, no-color-keywords\n\n// Colors\n//\n// Use the `color()` function to add colors to CSS properties. To learn more,\n// [read the Chroma documentation](http://johnalbin.github.io/chroma/).\n//\n// Markup: chroma.twig\n//\n// Weight: -1\n//\n// Style guide: sass.colors\n\n// Define the default color scheme's color names.\n$chroma: define-default-color-scheme('branding', 'The site\\'s main colors. Can be used to define colors in other color schemes.');\n\n$chroma: add-colors((\n  black:                  #000,\n  nearblack:              ('black' lighten 20%), // #333\n  grey-dark:              ('black' lighten 40%), // #666\n  'grey':                 ('black' lighten 60%), // #999\n  grey-light:             ('black' lighten 80%), // #ccc\n  grey-extra-light:       ('black' lighten 93.33%), // #eee\n  white:                  #fff,\n  blue:                   #0072b9,\n  red:                    #c00,\n  green:                  #43a808,\n  yellow:                 #fd0,\n  soft:                   #f5f5d5,\n  code-bg:                #f9f2f4\n));\n\n// Define color names for functional uses.\n$chroma: define-color-scheme('functional', 'Colors used by functional parts of the design.');\n$chroma: add-colors('functional', (\n  // Colors used in the main content area.\n  brand:                  'nearblack',\n  brand-alt:              'grey',\n  brand-dark:             'grey-dark',\n  text:                   'black',\n  text-bg:                'code-bg',\n\n  link:                   'black',\n  link-visited:           'black',\n  link-hover:             'brand',\n  link-active:            'red',\n\n  border:                 'grey-light',\n  border-dark:            'nearblack',\n\n  autocomplete:           'text',\n  autocomplete-bg:        'text-bg',\n  autocomplete-select:    'white',\n  autocomplete-select-bg: 'blue',\n\n  body-bg:                'soft',\n  header-bg:              'brand',\n  backdrop:               'soft',\n\n  mobile-menu:            'header-bg',\n\n  button:                 'nearblack',\n  button-disabled:        'grey',\n\n  form-error:             'red',\n\n  mark-highlight:         'red',\n  mark-bg:                'yellow',\n\n  menu-active:            'text',\n\n  preview-bg:             ('yellow' lighten 43%),\n\n  row-stripe:             'white',\n  row-disabled:           'grey-light',\n\n  status:                 'green',\n  status-bg:              (status lighten 62%),\n  status-highlight:       text,\n  warning:                text,\n  warning-bg:             ('yellow' lighten 45%),\n  warning-border:         'yellow',\n  error:                  'red',\n  error-bg:               (error lighten 57%),\n\n  watermark:              'grey-extra-light',\n\n  headings:               'nearblack',\n\n  code:                   'nearblack',\n));\n\n$chroma-active-scheme: 'functional';\n","// Variables\n//\n// Set variables for this site before a library sets its !default value.\n\n\n// Font faces, stacks and sizes.\n//\n// Font styling and line heights are controlled by the several variables that\n// used by mixins like `type-layout()`, `margin-top()`, and `margin-bottom()`.\n// These variable and mixins are documented on the [Typey\n// homepage](https://github.com/jptaranto/typey).\n\n// The font size set on the root html element.\n$base-font-size:    22px;\n$base-font-size-2:  18px;\n\n// The base line height determines the basic unit of vertical rhythm.\n$base-line-height:    31px;\n$base-line-height-2:  25px;\n\n$base-multiplier: $base-font-size / $base-font-size-2;\n\n$xxl-2: 34px * $base-multiplier;\n$xl-2:  28px * $base-multiplier;\n$l-2:   22px * $base-multiplier;\n$m-2:   18px * $base-multiplier;\n$s-2:   16px * $base-multiplier;\n$xs-2:  14px * $base-multiplier;\n\n// The font sizes in our type hierarchy as tee shirt sizes.\n$font-size: (\n  xxl:              28px,\n  xl:               26px,\n  l:                24px,\n  m:                $base-font-size,\n  s:                18px,\n  xs:               16px,\n  xxl-2:            $xxl-2,\n  xl-2:             $xl-2,\n  l-2:              $l-2,\n  m-2:              $m-2,\n  s-2:              $s-2,\n  xs-2:             $xs-2\n);\n\n// Typey allows you to alter font weights site-wide with this map.\n$font-weight: (\n  bold:             bold,\n  medium:           500,\n  normal:           normal,\n  light:            300,\n  lighter:          lighter,\n);\n\n// The following font family declarations use widely available fonts.\n// A user's web browser will look at the comma-separated list and will\n// attempt to use each font in turn until it finds one that is available\n// on the user's computer. The final \"generic\" font (sans-serif, serif or\n// monospace) hints at what type of font to use if the web browser doesn't\n// find any of the fonts in the list.\n\n// Serif font stacks.\n$times-new-roman: 'Times New Roman', Times, Georgia, 'DejaVu Serif', serif;\n$times:           Times, 'Times New Roman', Georgia, 'DejaVu Serif', serif;\n$georgia:         Georgia, 'Times New Roman', 'DejaVu Serif', serif;\n$garamond:        'Garamond Premier Pro', 'Adobe Garamond', Garamond, Charter, 'Times New Roman', serif;\n\n// Sans-serif font stacks.\n$verdana:         Verdana, Tahoma, 'DejaVu Sans', sans-serif;\n$tahoma:          Tahoma, Verdana, 'DejaVu Sans', sans-serif;\n$helvetica:       Helvetica, Arial, 'Nimbus Sans L', sans-serif;\n$arial:           Arial, Helvetica, 'Nimbus Sans L', sans-serif;\n$impact:          Impact, 'Arial Narrow', Helvetica, sans-serif;\n$lucida:          'Lucida Grande', 'Lucida Sans Unicode', Lucida, Verdana, sans-serif;\n$futura:          Futura, 'Century Gothic', AppleGothic, sans-serif;\n\n// Monospace font stacks.\n// For an explanation of why \"sans-serif\" is at the end of this list, see\n// http://meyerweb.com/eric/thoughts/2010/02/12/fixed-monospace-sizing/\n//$menlo:           Menlo, 'DejaVu Sans Mono', 'Ubuntu Mono', Courier, 'Courier New', monospace, sans-serif;\n$menlo:           Menlo, 'Ubuntu Mono', 'DejaVu Sans Mono', 'Courier New', Courier, monospace, sans-serif;\n\n// The font faces you specify in the $typefaces map can be used in the\n// typeface() mixin.\n$typefaces: (\n  body: (\n    font-family: $garamond,\n  ),\n  headings: (\n    font-family: $futura,\n  ),\n  monospace: (\n    font-family: $menlo,\n  ),\n  compact: (\n    font-family: $impact,\n    weight: bold,\n    case: uppercase,\n    // We could also specify the following property:\n    // letter-spacing: .5px,\n  ),\n);\n\n// Output a horizontal grid to help with debugging typography.\n$typey-debug: false;\n$with-wireframes: false;\n\n// The length unit in which to output font size and margin values.\n// Supported values: px, em, rem.\n$base-unit:         'rem';\n\n// px fallbacks for rem units are needed for IE 8 and earlier.\n$rem-fallback:      false;\n\n// We have separate print file.\n$auto-print-sizing: false;\n\n// Breakpoints\n//\n// Use the `respond-to()` mixin to use named breakpoints. Documentation is\n// available in the [Breakpoint wiki\n// pages](https://github.com/at-import/breakpoint/wiki/Respond-To).\n\n@include add-breakpoint(xxxs, (333px, 'no-query' true));\n@include add-breakpoint(xxs,  (444px, 'no-query' true));\n@include add-breakpoint(xs,   (555px, 'no-query' true));\n@include add-breakpoint(s,    (666px, 'no-query' true));\n@include add-breakpoint(m,    (777px, 'no-query' true));\n@include add-breakpoint(l,    (888px, 'no-query' true));\n@include add-breakpoint(xl,   (999px, 'no-query' true));\n@include add-breakpoint(xxl,  (1111px));\n@include add-breakpoint(xxxl, (1222px));\n\n// Output media queries where the above px are converted to ems.\n// @include breakpoint-set('to ems', true);\n\n\n// Layout\n\n// The max content width.\n$max-content-width: 960px;\n\n// The default left/right gutter/padding.\n$zen-gutters: 20px;\n\n\n// Miscellaneous variables\n//\n// `$indent-amount` controls the amount lists, blockquotes and comments are indented.\n//\n// `$include-rtl` controls whether RTL styles are output.\n//\n// weight: 10\n\n$indent-amount: 2 * $base-font-size;\n\n$include-rtl: false;\n","// Import the required partials for Chroma.\n\n@import './chroma/functions';\n@import './chroma/skin';\n","","// Skin module\n//\n// A \"Skin\" module for Chroma.\n//\n// Sometimes design and engineering requirements mean that we need to:\n// - output the colors for default color scheme and one or more additional color\n//   schemes into the same CSS file\n// - and to control which color scheme is used via a \"global\" CSS class name set\n//   on the web pages's `html` or `body` element.\n//\n// For example, the `.my-complexion` component may output a blue text color on\n// most pages, but on pages with a `<html class=\"skin-wicked-witch\">`, the\n// `.my-complexion` component will output a green text color.\n//\n// The Skin module will help with this requirement.\n//\n// After defining your color schemes and their colors, you can define one or\n// more of those schemes as skins while providing the proper CSS parent selector\n// to use for that skin.\n//\n// Weight: -1\n//\n// Style guide: skin\n\n@import \"./functions\";\n\n// skin([$skins])\n//\n// Output the default color and all the colors needed for defined skins.\n//\n// Usage:\n// ```scss\n// h1 {\n//   @include skin() {\n//     color: color(heading);\n//   }\n// }\n// ```\n//\n// $skins - An optional list of color scheme names and selectors to use instead\n//          of the skins defined with `define-skins()`. The format of this list\n//          should match that of the `$skins` parameter in `define-skins()`.\n//\n// Style guide: skin.skin\n@mixin skin($skins: null) {\n  @if type-of($skins) == 'null' {\n    $skins: map-get($chroma, 'skins');\n  }\n\n  // Save the current active scheme.\n  $original-active-scheme: $chroma-active-scheme;\n\n  // Output the default color property.\n  @content;\n\n  @if length($skins) == 0 {\n    @warn \"skin() mixin used, but no skins have been defined in Chroma.\";\n  }\n\n  // Output the color property for each scheme.\n  @each $scheme, $selector in $skins {\n    $chroma-active-scheme: $scheme !global;\n\n    #{$selector} & {\n      @content\n    }\n  }\n\n  // Restore the original active scheme.\n  $chroma-active-scheme: $original-active-scheme !global;\n}\n","","// KSS module\n//\n// A basic \"KSS\" module for Chroma.\n//\n// Use `chroma-kss-markup()` to export a chunk of HTML wrapped in a `/* */` CSS\n// comment. Then use `chroma-kss-styles()` to style it.\n//\n// @TODO: These functions and mixins are a bit janky because it exports to HTML\n// directly rather than to JSON or some other exportable data set.\n//\n// Style guide: kss\n\n@import \"./functions\";\n\n// chroma-kss-markup()\n//\n// Returns the HTML needed to display all colors in color() in a KSS style\n// guide. The parameters are used to specify the classes for various elements.\n//\n// Since regular text can only be output with Sass in certain contexts, you must\n// wrap this function call in a CSS comment.\n//\n// Usage:\n// ```scss\n// // Include chroma's optional kss module.\n// @import 'chroma/kss';\n// // Include the colors defined for your project.\n// @import 'init';\n//\n// /*\n// #{chroma-kss-markup()}\n// */\n// ```\n//\n// Then use a Gulp.js or Grunt task to strip the leading and trailing lines\n// (containing \"/*\" and \"*/\" respectively) from the generated file.\n//\n// $wrapper-class     - Defaults to 'kss-style'.\n// $title-class       - Defaults to 'chroma-kss__title'.\n// $description-class - Defaults to 'chroma-kss__description'.\n// $color-class       - Defaults to 'chroma-kss'.\n// $swatch-class      - Defaults to 'chroma-kss__swatch'.\n// $variable-class    - Defaults to 'chroma-kss__variable'.\n// $alt-text-class    - Defaults to 'chroma-kss__alt-text'.\n// $value-class       - Defaults to 'chroma-kss__value'.\n// $reference-class   - Defaults to 'chroma-kss__reference'.\n//\n// style guide: kss.chroma-kss-markup\n@function chroma-kss-markup(\n  $wrapper-class:     'kss-style',\n  $title-class:       'chroma-kss__title',\n  $description-class: 'chroma-kss__description',\n  $color-class:       'chroma-kss',\n  $swatch-class:      'chroma-kss__swatch',\n  $variable-class:    'chroma-kss__variable',\n  $alt-text-class:    'chroma-kss__alt-text',\n  $value-class:       'chroma-kss__value',\n  $reference-class:   'chroma-kss__reference'\n) {\n  $markup: '';\n\n  @each $scheme, $data in map-get($chroma, 'schemes') {\n    // Display the scheme name and description.\n    $markup: $markup\n      + '<h3 class=\"' + $title-class + '\">#{$scheme}</h3>'\n      + '<p class=\"' + $description-class + '\">#{map-get($data, 'description')}</p>';\n\n    // Display the colors in the scheme.\n    @each $color, $data in map-get($chroma, 'names') {\n      $seperator: str-index($color, '::');\n      @if $scheme == str-slice($color, 1, $seperator - 1) {\n        $color: str-slice($color, $seperator + 2);\n        $value: map-get($data, 'value');\n        $reference: map-get($data, 'reference');\n        $referenced_by: map-get($data, 'referenced_by');\n\n        // @TODO: node-sass 3.6.0 crashes with too many \"+\" operators in one command.\n        $markup: $markup\n          + '<div class=\"#{$color-class}\">'\n          +   '<span class=\"#{$swatch-class}\" style=\"background-color: #{$value}\"></span>';\n        $markup: $markup\n          +   '<code class=\"#{$variable-class}\">#{$_chroma-spelling}(#{$color})</code>'\n          +   ' <span class=\"#{$alt-text-class}\">uses the #{$_chroma-spelling}:</span> ';\n        $markup: $markup\n          +   '<span class=\"#{$value-class}\"><code>#{$value}</code>';\n        @if $reference {\n          $markup: $markup + ' (#{$reference})';\n        }\n        $markup: $markup + '</span>';\n        @if length($referenced_by) > 0 {\n          $markup: $markup + ' <span class=\"#{$reference_class}\">This #{$_chroma-spelling} is inherited by: ';\n          @for $i from 1 through length($referenced_by) {\n            $markup: $markup + nth($referenced_by, $i);\n            @if ($i != length($referenced_by)) {\n              $markup: $markup + ', ';\n            }\n          }\n          $markup: $markup + '</span>';\n        }\n        $markup: $markup + '</div>';\n      }\n    }\n  }\n\n  @if $markup and $wrapper-class {\n    $markup: '<div class=\"' + $wrapper-class + '\">' + $markup + '</div>';\n  }\n\n  $markup: '<!-- This markup is auto-generated from Sass with chroma-kss-markup(). Do not modify. -->' + $markup;\n\n  @return $markup;\n}\n\n// chroma-kss-styles()\n//\n// A mixin to add a series of rulesets that style Chroma color swatches in a KSS\n// style guide.\n//\n// Since the mixin writes CSS selectors, the mixin can be used at the root of a\n// stylesheet.\n//\n// Usage:\n// ```scss\n// // Include chroma's optional kss module.\n// @import 'chroma/kss';\n//\n// @include chroma-kss-styles();\n// ```\n//\n// $wrapper-class     - Defaults to 'kss-style'.\n// $title-class       - Defaults to 'chroma-kss__title'.\n// $description-class - Defaults to 'chroma-kss__description'.\n// $color-class       - Defaults to 'chroma-kss'.\n// $swatch-class      - Defaults to 'chroma-kss__swatch'.\n// $variable-class    - Defaults to 'chroma-kss__variable'.\n// $alt-text-class    - Defaults to 'chroma-kss__alt-text'.\n// $value-class       - Defaults to 'chroma-kss__value'.\n// $reference-class   - Defaults to 'chroma-kss__reference'.\n//\n// Style guide: kss.chroma-kss-styles\n@mixin chroma-kss-styles(\n  $wrapper-class:     'kss-style',\n  $title-class:       'chroma-kss__title',\n  $description-class: 'chroma-kss__description',\n  $color-class:       'chroma-kss',\n  $swatch-class:      'chroma-kss__swatch',\n  $variable-class:    'chroma-kss__variable',\n  $alt-text-class:    'chroma-kss__alt-text',\n  $value-class:       'chroma-kss__value',\n  $reference-class:   'chroma-kss__reference'\n) {\n  @if $wrapper-class {\n    .#{$wrapper-class} {\n      @include _chroma-kss-styles(\n        $title-class,\n        $description-class,\n        $color-class,\n        $swatch-class,\n        $variable-class,\n        $alt-text-class,\n        $value-class,\n        $reference-class\n      );\n    }\n  }\n  @else {\n    @include _chroma-kss-styles(\n      $title-class,\n      $description-class,\n      $color-class,\n      $swatch-class,\n      $variable-class,\n      $alt-text-class,\n      $value-class,\n      $reference-class\n    );\n  }\n}\n\n// _chroma-kss-styles()\n//\n// Helper mixin for chroma-kss-styles().\n//\n// No style guide reference.\n@mixin _chroma-kss-styles(\n  $title-class:       'chroma-kss__title',\n  $description-class: 'chroma-kss__description',\n  $color-class:       'chroma-kss',\n  $swatch-class:      'chroma-kss__swatch',\n  $variable-class:    'chroma-kss__variable',\n  $alt-text-class:    'chroma-kss__alt-text',\n  $value-class:       'chroma-kss__value',\n  $reference-class:   'chroma-kss__reference'\n  ) {\n\n  .#{$color-class} {\n    line-height: 50px;\n  }\n\n  .#{$swatch-class} {\n    display: inline-block;\n    width: 40px;\n    height: 40px;\n    border-radius: 40px;\n    border: 2px solid #000;\n    margin-right: 10px;\n    vertical-align: middle;\n  }\n\n  .#{$variable-class} {\n    margin-right: 10px;\n  }\n\n  .#{$alt-text-class} {\n    position: absolute !important;\n    height: 1px;\n    width: 1px;\n    overflow: hidden;\n    // IE6 and IE7 use the wrong syntax.\n    *clip: rect(1px 1px 1px 1px);\n    clip: rect(1px, 1px, 1px, 1px);\n  }\n\n  .#{$value-class} {\n    color: #bbb;\n\n    code {\n      color: #bbb;\n    }\n\n    &:before {\n      // \"\\2192\" is unicode for right arrow. \"\\ \" is a hack; otherwise space is\n      // ignored in some browsers.\n      content: '\\2192\\ ';\n      font-family: sans-serif;\n    }\n  }\n\n  .#{$reference-class} {\n    display: block;\n    position: relative;\n    top: -12px;\n    line-height: 25px;\n    padding-left: 50px;\n    color: #999;\n  }\n}\n","","/*! typey | GPLv2 License | https://github.com/jptaranto/typey */\n@import \"typey/functions/helpers\";\n@import \"typey/functions/validators\";\n@import \"typey/functions/em-calculators\";\n@import \"typey/functions/outputters\";\n@import \"typey/functions/sizers\";\n@import \"typey/functions/extras\";\n@import \"typey/functions/depreciated\";\n@import \"typey/font-stacks\";\n@import \"typey/defaults\";\n@import \"typey/mixins/debug\";\n@import \"typey/mixins/define-type-sizing\";\n@import \"typey/mixins/font-size\";\n@import \"typey/mixins/line-height\";\n@import \"typey/mixins/spacing\";\n@import \"typey/mixins/typeface\";\n@import \"typey/mixins/typeset\";\n@import \"typey/mixins/type-layout\";\n","// Output a number in the $base-unit.\n//\n// @param number $number\n//   The number (without unit) to output.\n//\n// @return number\n//   The number with the base unit\n@function typey-output-in-base-unit($number) {\n  @if $number == 0 {\n    @return 0;\n  }\n  @if $base-unit == rem {\n    @return $number * 1rem;\n  }\n  @if $base-unit == px {\n    @return $number * 1px;\n  }\n  @if $base-unit == em {\n    @return $number * 1em;\n  }\n}\n\n// Output a number in a chosen unit.\n//\n// @param number $number\n//   The number (without unit) to output.\n// @param string $unit\n//   (optional) The unit to output, either em, px or rem.\n//\n// @return number\n//   The number with the base unit\n@function typey-output-in-unit($number, $unit: $base-unit) {\n  @if $number == 0 {\n    @return 0;\n  }\n  @if $unit == rem {\n    @return $number * 1rem;\n  }\n  @if $unit == px {\n    @return $number * 1px;\n  }\n  @if $unit == em {\n    @return $number * 1em;\n  }\n}\n\n// Remove the unit from a number.\n//\n// @param number $number\n//   The number (with unit) to convert. Allowed units: any\n//\n// @return number\n//   The number without the unit.\n@function typey-strip-unit($number) {\n  @if type-of($number) == \"number\" and not unitless($number) {\n    @return $number / ($number * 0 + 1);\n  }\n  @return $number;\n}\n","// Takes a value and checks to ensure it's expressed correctly then returns\n// the type.\n//\n// @param number|string|list $x\n//   A multiple of $base-line-height.\n//   A px value.\n//   A size from the $font-size map.\n//   A space seperated list container multiples and/or px values.\n//\n// @return string\n//   multiplier, px, font-size, list\n@function typey-check-value($x) {\n  @if type-of($x) == \"number\" {\n    @if unitless($x) {\n      @return \"multiplier\";\n    }\n    @if not unitless($x) {\n      @if unit($x) == px {\n        @return \"px\";\n      }\n      @else {\n        @error \"All units must be expressed in px\";\n      }\n    }\n  }\n  @if type-of($x) == \"string\" {\n    @if $x == \"auto\" {\n      @return \"auto\";\n    }\n    @if map-has-key($font-size, $x) {\n      @return \"font-size\";\n    }\n    @else {\n      @error \"'#{$x}' not found in $font-size map\";\n    }\n  }\n  @if type-of($x) == \"list\" {\n    @if list-separator($x) == space {\n      @each $value in $x {\n        @if type-of($value) == \"number\" or $value == \"auto\" {\n          @if type-of($value) == \"number\" {\n            @if not unitless($value) and unit($value) != px {\n              @error \"All units must be expressed in px\";\n            }\n          }\n        }\n        @else {\n          @error \"Values specified inside lists must be a number or 'auto'\";\n        }\n      }\n      @return \"list\";\n    }\n    @else {\n      @error \"All lists must use a space as their seperator\";\n    }\n  }\n  @else {\n    @return type-of($x);\n  }\n}\n\n// Takes a value and validates it against a specified type.\n//\n// @param number|string|list $x\n//   A multiple of $base-line-height.\n//   A px value.\n//   A size from the $font-size map.\n//   A space seperated list container multiples and/or px values.\n// @param string|list $allowed-types\n//   Either multiplier, px, font-size, list, or a comibation specified in a list.\n//\n// @return string\n//   The values type.\n@function typey-validator($x, $allowed-types) {\n  $type: typey-check-value($x);\n  @if index($allowed-types, $type) != null {\n    @return $type;\n  }\n  @else {\n    @error \"'#{$type}' is not a valid type for this function (allowed types are: #{$allowed-types})\";\n  }\n}\n","// Calculate relative sizing for em when a px value is used.\n//\n// @param number $number\n//   The px value\n// @param number|string $context\n//   The relative value to perform the calculation.\n//\n// @return number\n//   The calculated value in the base unit.\n@function calculate-em-px($x, $context) {\n  $allowed-types: \"font-size\", \"px\";\n  $type: typey-validator($context, $allowed-types);\n  @if $type == \"font-size\" {\n    $context-map-size: map-get($font-size, $context);\n    @return typey-output-in-unit(($x / $context-map-size), em);\n  }\n  @if $type == \"px\" {\n    @return typey-output-in-unit(($x / $context), em);\n  }\n}\n\n// Calculate relative sizing for em when a multiplier is used.\n//\n// @param number $number\n//   Multiple of line height to be used.\n// @param number|string $context\n//   The relative value to perform the calculation.\n//\n// @return number\n//   The calculated value in the base unit.\n@function calculate-em-multiplier($x, $context) {\n  $allowed-types: \"font-size\", \"px\";\n  $type: typey-validator($context, $allowed-types);\n  @if $type == \"font-size\" {\n    $context-map-size: map-get($font-size, $context);\n    @return typey-output-in-unit(($x * $base-line-height) / $context-map-size, em);\n  }\n  @if $type == \"px\" {\n    @return typey-output-in-unit(($x * $base-line-height) / $context, em);\n  }\n}\n","// Take a px value and output converted value.\n//\n// @param number $number\n//   A px value to convert.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the elements/parents\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n//\n// @return number\n//   The number converted to the base unit.\n@function output-from-px($number, $context: $base-font-size) {\n  @if $base-unit == rem {\n    @return typey-output-in-base-unit(($number / $base-font-size));\n  }\n  @if $base-unit == px {\n    @return typey-output-in-base-unit(typey-strip-unit($number));\n  }\n  @if $base-unit == em {\n    @return calculate-em-px($number, $context);\n  }\n}\n\n// Take a key from the $font-size map and output converted value.\n//\n// @param string $size\n//   A size from the $font-size map.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the parent\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n//\n// @return number\n//   The selected font-size in $base-unit.\n@function output-from-font-size-map($size, $context: $base-font-size) {\n  $map-size: map-get($font-size, $size);\n  @if $base-unit == rem {\n    @return typey-output-in-base-unit(($map-size / $base-font-size));\n  }\n  @if $base-unit == px {\n    @return typey-output-in-base-unit(typey-strip-unit($map-size));\n  }\n  @if $base-unit == em {\n    @return calculate-em-px($map-size, $context);\n  }\n}\n\n// Take a line-height multipler and output converted value.\n//\n// @param number $number\n//   Multiple of line height to be used.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the elements/parents\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n//\n// @return number\n//   The value of the line-height multiple converted to the base unit.\n@function output-from-multiplier($x, $context: $base-font-size) {\n  @if $base-unit == rem {\n    @return typey-output-in-base-unit(($x * $base-line-height) / $base-font-size);\n  }\n  @if $base-unit == px {\n    @return typey-output-in-base-unit(typey-strip-unit($x * $base-line-height));\n  }\n  @if $base-unit == em {\n    @return calculate-em-multiplier($x, $context);\n  }\n}\n\n// Take a line-height ratio and output as em.\n//\n// @param number $ratio\n//   Multiple of the $font-size to be used.\n// @param number|string $context\n//  (optional) used to ensure function outputs the ratio regardless of whether\n//  it is the same as the $base-line-height-ratio.\n//\n// @return number\n//   The ratio in em.\n@function output-from-ratio($ratio: $base-line-height-ratio) {\n  @return $ratio;\n}\n","// Takes a sizing from the $font-size map (m, xl, xxl, etc) and convert it to\n// the base unit. Alternatively convert a px font-size into the base unit.\n//\n// @param number|string $size\n//   A size from the $font-size map or px value to be converted\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the parent\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n//\n// @return number\n//   The selected font-size in $base-unit.\n@function font-size($size, $context: $base-font-size) {\n  $allowed-types: \"font-size\", \"px\";\n  $type: typey-validator($size, $allowed-types);\n  @if $type == \"font-size\" {\n    @return output-from-font-size-map($size, $context);\n  }\n  @if $type == \"px\" {\n    @return output-from-px($size, $context);\n  }\n}\n\n// Generate a value to be used as line-height from either:\n//   a) a multiple of $base-line-height\n//   b) a static px value\n//   c) a ratio of the font-size\n//\n// Example usage with multiple:\n//   line-height: line-height(2);\n// Example usage with static value:\n//   line-height: line-height(18px);\n// Example usage with ratio:\n//   line-height: line-height(1.5);\n//\n// @param number $x\n//   Multiple of $base-line-height to be used, px value to be converted, or ratio of\n//   font-size.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the\n//   elements/parents font-size if it differs from $base-font-size.\n//   Specified as a t-shirt size or value in px.\n// @return number\n//   The calculated height in $base-unit.\n@function line-height($x, $context: $base-font-size) {\n  $allowed-types: \"multiplier\", \"px\";\n  $type: typey-validator($x, $allowed-types);\n  @if $type == \"multiplier\" {\n    @if ($line-height-method == \"ratio\") {\n      @return output-from-ratio($x);\n    }\n    @else {\n      @return output-from-multiplier($x, $context);\n    }\n  }\n  @if $type == \"px\" {\n    @return output-from-px($x, $context);\n  }\n}\n\n// Generate a value to be used as some form of height or spacing from either:\n//   a) a multiple of $base-line-height\n//   b) a static px value\n//\n// Example usage with multiple:\n//   height: spacing(2);\n// Example usage with static value:\n//   margin-bottom: spacing(18px);\n//\n// @param number $x\n//   Multiple of $base-line-height to be used or px value to be converted.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the elements/parents\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n//\n// @return number\n//   The calculated spacing in $base-unit.\n@function spacing($x, $context: $base-font-size) {\n  $allowed-types: \"multiplier\", \"px\", \"auto\";\n  $type: typey-validator($x, $allowed-types);\n  @if $type == \"multiplier\" {\n    @return output-from-multiplier($x, $context);\n  }\n  @if $type == \"px\" {\n    @return output-from-px($x, $context);\n  }\n  @if $type == \"auto\" {\n    @return auto;\n  }\n}\n","// Retrieve a font weight.\n//\n// @param string $weight\n//   A weight from the $font-weight map.\n//\n// @return string\n//   The selected font-weight.\n@function weight($weight) {\n  @if type-of($weight) == \"string\" {\n    @if map-has-key($font-weight, $weight) {\n      @return map-get($font-weight, $weight);\n    }\n    @else {\n      @error \"'#{$weight}' not found in $font-weight map\";\n    }\n  }\n  @else {\n    @error \"Weight specified for weight() is not a string\";\n  }\n}\n\n// Extend a font by adding a web-safe stack to it.\n//\n// Example usage:\n//   $new-font-stack: extend-font-stack(\"Open sans\", $sans-serif-stack);\n//\n// @param string $font\n//   The name of the font. Use inverted commas if there are spaces in the font\n//   name. i.e \"Open sans\"\n// @param list $font-stack\n//   The font stack variable to extend.\n@function extend-font-stack($font, $font-stack) {\n  @return join($font, $font-stack, $separator: comma);\n}\n","// DEPRECIATED FUNCTIONS\n// The names of these functions have been refined and namespaced (above) to avoid\n// potential confusion with functions from other libraries.\n\n// (Depreciated) Output a number in the $base-unit..\n//\n// @param string $weight\n//   A weight from the $font-weight map.\n//\n// @return string\n//   The selected font-weight.\n@function output-unit($number) {\n  @warn \"output-unit() is depreciated. Please use typey-output-in-base-unit() instead\";\n  @return typey-output-in-base-unit($number);\n}\n\n// (Depreciated) Remove the unit from a number.\n//\n// @param number $number\n//   The number (with unit) to convert. Allowed units: any\n//\n// @return number\n//   The number without the unit.\n@function strip-unit($number) {\n  @warn \"strip-unit() is depreciated. Please use typey-strip-unit() instead\";\n  @return typey-strip-unit($number);\n}\n\n// (Depreciated) Convert px to the $base-unit.\n//\n// @param number $number\n//   The number (with unit) to convert. Allowed units: px\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the elements/parents\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n//\n// @return number\n//   The number converted to the base unit.\n@function convert-unit($number, $context: $base-font-size) {\n  @warn \"convert-unit() is depreciated. Please use output-from-px() instead\";\n  @return output-from-px($number, $context);\n}\n\n// (Depreciated) Retrieve a font weight.\n//\n// @param string $weight\n//   A weight from the $font-weight map.\n//\n// @return string\n//   The selected font-weight.\n@function font-weight($weight) {\n  @warn \"font-weight() is depreciated. Please use weight() instead\";\n  @return weight($weight);\n}\n","// Three standard do-all stacks.\n$serif-stack:         \"Calisto MT\", \"Book Antiqua\", serif !default;\n$sans-serif-stack:    \"Helvetica Neue\", Helvetica, sans-serif !default;\n$monospace-stack:     Consolas, \"Lucida Console\", monospace, monospace !default;\n","// The browser font size default. No need to change this.\n// Allowed units: px\n$browser-font-size:        16px !default;\n\n// Allowed units: rem, em or px\n$base-unit:                rem !default;\n\n// The base font size will be used for most calculations involving font-size.\n// Allowed units: px\n$base-font-size:           16px !default;\n\n// The base line height will be used for most calculations involving height.\n// Allowed units: px\n$base-line-height:         24px !default;\n\n// The method to calculate line-height. Allowed values: rhythm or ratio.\n// Rhytm uses a vertical rhythm approach where line-height is specified as\n// a multiple of the $base-line-height.\n// Ratio uses a ratio approach where line-height is specified as a ratio\n// of the elements font-size.\n$line-height-method:       rhythm !default;\n\n// The default ratio of line-height to font-size.\n$base-line-height-ratio:   1.5 !default;\n\n// By default we will provide fallbacks when rem is the base unit.\n$rem-fallback:             true !default;\n\n// By default, when rem or em are the base unit we will output a print suitable\n// media query with the define-type-sizing() mixin. This will take care of all\n// print media type sizing effortlessly.\n$auto-print-sizing:        true !default;\n\n// The pt font-size to be used with the print media query when\n// $auto-print-sizing is enabled.\n// Allowed units: pt\n$print-font-size:          12pt !default;\n\n// Default font sizes\n// Once you redefine the $font-size map it will overwrite all sizes here.\n// Allowed units: px\n$font-size: (\n  xxxl:                    60px,\n  xxl:                     46px,\n  xl:                      32px,\n  l:                       24px,\n  m:                       16px,\n  s:                       14px,\n  xs:                      12px\n) !default;\n\n// Default font weights\n// This map and accompanying function help provide granular control over\n// setting and retrieving static font weights.\n$font-weight: (\n  bold:                    700,\n  normal:                  400,\n  lighter:                 200\n) !default;\n\n// Declare typefaces\n// These can use any key you like, and allow you to set global letter-spacing,\n// weight and case for font-families. You can then use the\n// font-family mixin to embed your font families anywhere you like.\n//\n// Each key in the $typefaces map can either be a keyed map of settings\n// using any combination of the keys below, or it can be a shorthand list\n// of each property value. When using shorthand it doesn't matter what order\n// each value is arranged in, but best practice is to do it in the order:\n// [font-family] [letter-spacing] [weight] [case]\n//\n// @setting list font-family\n//   Any standard CSS font-family. Use typey pre-written stacks or roll your own.\n// @setting number letter-spacing\n//   CSS letter-spacing. Specified as a px value when font-size is the\n//   $base-font-size.\n// @setting string weight\n//   A key from the $font-weight map. Only specify this if you want a consistant\n//   font-weight used accross the board with this typeface.\n// @setting string case\n//   A value for CSS text-transform. Only specify this if you want a consistant\n//   case used accross the board with this typeface.\n$typefaces: () !default;\n\n// Declare typestyles\n// These can use any key you like, and allow you to set an easily reusable type\n// style. They can be as simple as a font-size and line-height, or can go on\n// to encompass a full range of css type properties.\n//\n// Each key in the $typestyles map can either be a keyed map of settings\n// using any combination of the keys below, or it can be a shorthand list\n// of each property value. When using shorthand for $typestyles, the first value\n// must always be font-size. After that it doesn't matter what order each value\n// is arranged in, but best practice is to do it in the order:\n// [font-size] [line-height] [weight] [case]\n//\n// @setting number|string font-size\n//   A size from the $font-size map or px value to be converted\n// @setting number $x line-height\n//   Multiple of line height, ratio or px value to be converted.\n// @setting string weight\n//   A key from the $font-weight map.\n// @setting string case\n//   A value for CSS text-transform.\n$typestyles: () !default;\n\n// Debug grid\n// Shows horizontal lines for each elements line height.\n$typey-debug:              false !default;\n\n// Debug grid coloring\n$typey-debug-color:        #4affff !default;\n\n// Lets store the allowed values for text-transform and font-style so we can\n// make shorthand work a little better.\n$text-transform-values: (\n  lowercase,\n  uppercase,\n  capitalize\n) !default;\n\n$font-style-values: (\n  normal,\n  italic,\n  oblique\n) !default;\n\n// Warnings for $base-unit.\n@if $base-unit != px and $base-unit != rem and $base-unit != em {\n  @error \"$base-unit must be one of the following unit types: rem, em or px\";\n}\n\n// Warnings for $base-font-size and $base-line-height.\n@if unit($base-font-size) != px {\n  @error \"$base-font-size must be in px\";\n}\n@if unit($base-line-height) != px {\n  @error \"$base-line-height must be in px\";\n}\n\n// Warnings for $print-font-size.\n@if unit($print-font-size) != pt {\n  @error \"$print-font-size must be in pt\";\n}\n\n// Warnings for $font-size.\n@each $key, $size in $font-size {\n  @if unit($size) != px {\n    @error \"Size '#{$key}' in $font-size map is not specified in px\";\n  }\n}\n\n// Warnings for $font-weight.\n$typey-text-transform-properties: none capitalize uppercase lowercase initial inherit;\n@each $property in $typey-text-transform-properties {\n  @if map-has-key($font-weight, $property) {\n    @warn \"'#{$property}' used in $font-weight map is a potential value of the text-transform property and will conflict when using typey shorthand\";\n  }\n}\n\n// Warnings for $typefaces.\n@each $key, $typeface in $typefaces {\n  @if type-of($typeface) != \"map\" and type-of($typeface) != \"list\" {\n    @error \"Typeface '#{$key}' in $typefaces map must be a keyed map or a shorthand list in the format: [font-family] [letter-spacing] [weight] [case]\";\n  }\n}\n\n// Warnings for $typestyles.\n@each $key, $typestyle in $typestyles {\n  @if type-of($typestyle) == \"list\" {\n    @each $value in $typestyle {\n      @if index($typestyle, $value) == 1 {\n        $allowed-types: \"font-size\", \"px\";\n        $type: typey-check-value($value);\n        @if index($allowed-types, $type) == null {\n          @error \"Incorrect shorthand format used in '#{$key}' in $typestyles map: [font-size] must appear first\";\n        }\n      }\n    }\n  }\n}\n","// Output a horizontal grid to help with debugging typography.\n//\n// @param number $line-height\n//   Multiple of line height to be used, line-height ratio or px value to be converted.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the\n//   elements/parents font-size if it differs from $base-font-size.\n//   Specified as a t-shirt size or value in px.\n// @param string $color\n//   (optional) Use a custom grid color.\n@mixin typey-debug-grid($line-height: $base-line-height, $context: $base-font-size, $color: $typey-debug-color) {\n  @if $typey-debug == true {\n    $allowed-types: \"multiplier\", \"px\";\n    $type: typey-validator($line-height, $allowed-types);\n    $grid-height: 0;\n    @if $line-height-method == \"rhythm\" {\n      $grid-height: line-height($line-height, $context);\n    }\n    @if $line-height-method == \"ratio\" {\n      @if $line-height == $base-line-height {\n        $grid-height: line-height($base-line-height-ratio, $context) * 1em;\n      }\n      @else {\n        $grid-height: line-height($line-height, $context) * 1em;\n      }\n    }\n\n    position: relative;\n    background-image: repeating-linear-gradient(180deg, $color, $color 1px, transparent 1px, transparent $grid-height);\n\n    &:after {\n      content: \"\";\n      position: absolute;\n      bottom: -1px;\n      left: 0;\n      height: 1px;\n      width: 100%;\n      background-color: $color;\n    }\n  }\n}\n","// Define defaults (use this in the HTML element).\n//\n// @param number $size\n//   (optional) The font-size. Use to set to anything other than $base-font-size.\n// @param number $line-height\n//   (optional) The line-height. Use to set to anything other than $base-line-height.\n//   Set to a ratio when $line-height-as-ratio is true. Will default to $base-line-height-ratio.\n//   Set to false if you do not want to change a ratio of line-height already set.\n@mixin define-type-sizing($size: $base-font-size, $line-height: $base-line-height) {\n  @if $base-unit == rem or $base-unit == em {\n    font-size: $size / $browser-font-size * 100%;\n  }\n  @if $base-unit == px {\n    font-size: $size;\n  }\n\n  @if $line-height != false {\n    @if $line-height-method == \"ratio\" {\n      @if $line-height == $base-line-height {\n        $line-height: $base-line-height-ratio;\n      }\n      line-height: $line-height;\n    }\n    @else {\n      @if $base-unit == rem or $base-unit == em {\n        // In the html element, rem means relative to browser default font size; em means relative to html's font size.\n        line-height: calculate-em-px($line-height, $size);\n      }\n      @if $base-unit == px {\n        line-height: $line-height;\n      }\n    }\n  }\n\n  @if $auto-print-sizing == true {\n    @if $base-unit == rem or $base-unit == em {\n      @media print {\n        font-size: $print-font-size;\n      }\n    }\n    @else {\n      @warn \"As you are not using a relative base unit (rem or em) automatic print media sizing will not work. Set $auto-print-sizing to false to hide this warning\"\n    }\n  }\n}\n","// Define font-size (with fallback)\n//\n// @param number|string $size\n//   A size from the $font-size map or px value to be converted\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the elements/parents\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n@mixin font-size($size, $context: $base-font-size) {\n  $allowed-types: \"font-size\", \"px\";\n  $type: typey-validator($size, $allowed-types);\n  @if $base-unit == rem {\n    @if $rem-fallback == true {\n      @if $type == \"font-size\" {\n        $map-size: map-get($font-size, $size);\n        font-size: $map-size;\n      }\n      @if $type == \"px\" {\n        font-size: $size;\n      }\n    }\n  }\n  font-size: font-size($size, $context);\n}\n","// Define line-height (with fallback).\n//\n// @param number $x\n//   Multiple of line height to be used or px value to be converted.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the\n//   elements/parents font-size if it differs from $base-font-size.\n//   Specified as a t-shirt size or value in px.\n@mixin line-height($x, $context: $base-font-size) {\n  $allowed-types: \"multiplier\", \"px\";\n  $type: typey-validator($x, $allowed-types);\n  @if $base-unit == rem and $line-height-method == \"rhythm\" {\n    @if $rem-fallback == true {\n      @if $type == \"multiplier\" {\n        line-height: $x * $base-line-height;\n      }\n      @if $type == \"px\" {\n        line-height: $x;\n      }\n    }\n  }\n  line-height: line-height($x, $context);\n}\n","// Define spacing (with fallbacks).\n//\n// @param string $type\n//   The type of spacing: margin, padding, margin-top, etc.\n// @param number|list|string $spacing\n//   Multiple of $base-line-height to be used or px value to be converted.\n//   Can be a SASS list using the same parameters as the CSS margin property:\n//   i.e. top right bottom left, 1 0 2 0.\n//   Can also be the string \"auto\" when used as margin.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the elements/parents\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n@mixin spacing($property, $spacing, $context: $base-font-size) {\n  $allowed-types: \"multiplier\", \"px\", \"list\";\n  $type: typey-validator($spacing, $allowed-types);\n\n  $px-fallback-list: ();\n  $converted-list: ();\n\n  @each $x in $spacing {\n    @if $base-unit == rem {\n      $allowed-types: \"multiplier\", \"px\", \"auto\";\n      $type: typey-validator($x, $allowed-types);\n      @if $type == \"multiplier\" {\n        $spacing: $x * $base-line-height;\n        $px-fallback-list: join($px-fallback-list, $spacing, $separator: space);\n      }\n      @if $type == \"px\" {\n        $px-fallback-list: join($px-fallback-list, $x, $separator: space);\n      }\n      @if $type == \"auto\" {\n        $px-fallback-list: join($px-fallback-list, $x, $separator: space);\n      }\n    }\n    $spacing: spacing($x, $context);\n    $converted-list: join($converted-list, $spacing, $separator: space);\n  }\n\n  @if $base-unit == rem {\n    @if $rem-fallback == true {\n      #{$property}: $px-fallback-list;\n    }\n  }\n  #{$property}: $converted-list;\n}\n\n// Wrapper mixins for various spacing properties.\n// These can be used to provide easily sized spacing in the base unit.\n//\n// @param number|list|string $x\n//   Multiple of $base-line-height to be used or px value to be converted.\n//   Can be a SASS list using the same parameters as the CSS margin property:\n//   i.e. top right bottom left, 1 0 2 0.\n//   Can also be the string \"auto\" when used as margin.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the elements/parents\n//   font-size if it differs from $base-font-size. Specified as a t-shirt size or\n//   value in px.\n@mixin margin($x, $context: $base-font-size) {\n  @include spacing(margin, $x, $context);\n}\n@mixin margin-top($x, $context: $base-font-size) {\n  @include spacing(margin-top, $x, $context);\n}\n@mixin margin-bottom($x, $context: $base-font-size) {\n  @include spacing(margin-bottom, $x, $context);\n}\n@mixin margin-left($x, $context: $base-font-size) {\n  @include spacing(margin-left, $x, $context);\n}\n@mixin margin-right($x, $context: $base-font-size) {\n  @include spacing(margin-right, $x, $context);\n}\n@mixin padding($x, $context: $base-font-size) {\n  @include spacing(padding, $x, $context);\n}\n@mixin padding-top($x, $context: $base-font-size) {\n  @include spacing(padding-top, $x, $context);\n}\n@mixin padding-bottom($x, $context: $base-font-size) {\n  @include spacing(padding-bottom, $x, $context);\n}\n@mixin padding-left($x, $context: $base-font-size) {\n  @include spacing(padding-left, $x, $context);\n}\n@mixin padding-right($x, $context: $base-font-size) {\n  @include spacing(padding-right, $x, $context);\n}\n","// Embed a typeface.\n//\n// @param string $typeface\n//   A font family from the $typefaces map.\n@mixin typeface($typeface) {\n  $typeface-name: $typeface;\n  $typeface: map-get($typefaces, $typeface);\n\n  $font-family: false;\n  $letter-spacing: false;\n  $weight: false;\n  $style: false;\n  $case: false;\n\n  // Assign values to variables when $typeface is a keyed map.\n  @if type-of($typeface) == \"map\" {\n    @if map-has-key($typeface, font-family) {\n      $font-family: map-get($typeface, font-family);\n    }\n    @if map-has-key($typeface, letter-spacing) {\n      $letter-spacing: map-get($typeface, letter-spacing);\n    }\n    @if map-has-key($typeface, weight) {\n      $weight: map-get($typeface, weight);\n    }\n    @if map-has-key($typeface, style) {\n      $style: map-get($typeface, style);\n    }\n    @if map-has-key($typeface, case) {\n      $case: map-get($typeface, case);\n    }\n  }\n\n  // Assign values to variables when $typeface is shorthand.\n  @if type-of($typeface) == \"list\" {\n    @if (list-separator($typeface) == \"comma\") {\n      // This shorthand is just a list of fonts.\n      $font-family: $typeface;\n    }\n    @else {\n      @each $value in $typeface {\n        // This is a font-family.\n        @if type-of($value) == \"list\" {\n          $font-family: $value;\n        }\n        // This is a letter-spacing value.\n        @if type-of($value) == \"number\" {\n          $letter-spacing: $value;\n        }\n        // This is a font-weight value.\n        @if map-has-key($font-weight, $value) {\n          $weight: $value;\n        }\n        // This is a case value.\n        @else if type-of($value) == \"string\" and index($text-transform-values, $value) != null {\n          $case: $value;\n        }\n        // This is a style value.\n        @else if type-of($value) == \"string\" and index($font-style-values, $value) != null {\n          $style: $value;\n        }\n      }\n    }\n  }\n\n  // Output properties.\n  @if $font-family {\n    font-family: $font-family;\n  }\n  @else {\n    @error \"Typeface '#{$typeface-name}' does not have a font-family\";\n  }\n  @if $letter-spacing {\n    @if ($letter-spacing == 0) {\n      letter-spacing: 0;\n    }\n    @else {\n      letter-spacing: calculate-em-px($letter-spacing, $base-font-size);\n    }\n  }\n  @if $weight {\n    font-weight: weight($weight);\n  }\n  @if $style {\n    font-style: $style;\n  }\n  @if $case {\n    text-transform: $case;\n  }\n}\n","// Typeset your type.\n//\n// @param string $typestyle\n//   A type style from the $typestyles map.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the\n//   elements/parents font-size if it differs from $base-font-size.\n//   Specified as a t-shirt size or value in px.\n@mixin typeset($typestyle, $context: $base-font-size) {\n  $typestyle: map-get($typestyles, $typestyle);\n\n  $font-size: false;\n  $line-height: false;\n  $weight: false;\n  $style: false;\n  $case: false;\n  $letter-spacing: false;\n\n  // Assign values to variables when $typestyle is a keyed map.\n  @if type-of($typestyle) == \"map\" {\n    @if map-has-key($typestyle, font-size) {\n      $font-size: map-get($typestyle, font-size);\n    }\n    @if map-has-key($typestyle, line-height) {\n      $line-height: map-get($typestyle, line-height);\n    }\n    @if map-has-key($typestyle, weight) {\n      $weight: map-get($typestyle, weight);\n    }\n    @if map-has-key($typestyle, style) {\n      $style: map-get($typestyle, style);\n    }\n    @if map-has-key($typestyle, case) {\n      $case: map-get($typestyle, case);\n    }\n    @if map-has-key($typestyle, letter-spacing) {\n      $letter-spacing: map-get($typestyle, letter-spacing);\n    }\n  }\n\n  // Assign values to variables when $typestyle is shorthand.\n  @if type-of($typestyle) == \"list\" {\n    @each $value in $typestyle {\n      // The first value is always font-size.\n      @if index($typestyle, $value) == 1 {\n        $font-size: $value;\n      }\n      // This is a line-height value.\n      @else if type-of($value) == \"number\" and index($typestyle, $value) == 2 {\n        $line-height: $value;\n      }\n      // This is a font-weight value.\n      @else if map-has-key($font-weight, $value) {\n        $weight: $value;\n      }\n      // This is a case value.\n      @else if type-of($value) == \"string\" and index($text-transform-values, $value) != null {\n        $case: $value;\n      }\n      // This is a style value.\n      @else if type-of($value) == \"string\" and index($font-style-values, $value) != null {\n        $style: $value;\n      }\n      // This is a letter-spacing value.\n      @else if type-of($value) == \"number\" and index($typestyle, $value) != 2 and index($typestyle, $value) != 1 {\n        $letter-spacing: $value;\n      }\n    }\n  }\n\n  // $typestyle may also be a solitary font-size.\n  @if type-of($typestyle) != \"map\" and type-of($typestyle) != \"list\" {\n    $font-size: $typestyle;\n  }\n\n  // Output properties.\n  @if $font-size {\n    @include font-size($font-size, $context);\n  }\n  @if $line-height {\n    @include typey-debug-grid($line-height, $font-size);\n    @include line-height($line-height, $font-size);\n  }\n  @else {\n    // Using default line-height so set debug grid accordingly.\n    @include typey-debug-grid($base-line-height, $font-size);\n  }\n  @if $weight {\n    font-weight: weight($weight);\n  }\n  @if $style {\n    font-style: $style;\n  }\n  @if $case {\n    text-transform: $case;\n  }\n  @if $letter-spacing {\n    letter-spacing: calculate-em-px($letter-spacing, $font-size);\n  }\n}\n","// Define a type layout (font-size and line-height).\n//\n// @param number|string $size\n//   A size from the $font-size map or a px value.\n// @param number $line-height\n//   Multiple of line height to be used or px value to be converted.\n// @param number|string $context\n//   (optional) Only used if em is the $base-unit. The value of the\n//   elements/parents font-size if it differs from $base-font-size.\n//   Specified as a t-shirt size or value in px.\n@mixin type-layout($size, $line-height, $context: $base-font-size) {\n  @include font-size($size, $context);\n  @include line-height($line-height, $size);\n  @include typey-debug-grid($line-height, $size);\n}\n","// clearfix()\n//\n// Allows the bottom of an element to extend to the bottom of all floated\n// children elements. @see http://nicolasgallagher.com/micro-clearfix-hack/\n//\n// We use the micro-clearfix, optimized for use in `@extend` where fewer `&` is\n// better.\n//\n// Style guide: sass.mixins.clearfix\n@mixin clearfix() {\n  &::before {\n    content: '';\n    display: table;\n  }\n\n  &::after {\n    content: '';\n    display: table;\n    clear: both;\n  }\n}\n","$include-rtl: true !default;\n\n// rtl()\n//\n// Includes Right-To-Left language support by adding a parent selector of\n// `[dir=\"rtl\"]`. Since the dir attribute is usually defined on the html element\n// of a page, using this mixin on a ruleset that matches the html element won't\n// work.\n//\n// Can be turned off globally by setting `$include-rtl: false;`.\n//\n// $selector = '[dir=\"rtl\"]' - The RTL parent selector.\n//\n// Style guide: sass.mixins.rtl\n@mixin rtl($selector: '[dir=\"rtl\"]') {\n  @if $include-rtl {\n    @if & {\n      #{$selector} & {\n        @content;\n      }\n    }\n    @else {\n      #{$selector} {\n        @content;\n      }\n    }\n  }\n}\n","// sass-lint:disable no-important\n\n// visually-hidden()\n//\n// Make an element visually hidden, but accessible to screen readers, etc.\n// @see http://snook.ca/archives/html_and_css/hiding-content-for-accessibility\n//\n// Style guide: sass.mixins.visually-hidden\n@mixin visually-hidden {\n  position: absolute !important;\n  height: 1px;\n  width: 1px;\n  overflow: hidden;\n  clip: rect(1px, 1px, 1px, 1px);\n  word-wrap: normal;\n}\n\n// visually-hidden--off()\n//\n// Turns off the visually-hidden effect.\n//\n// Style guide: sass.mixins.visually-hidden--off\n@mixin visually-hidden--off {\n  position: static !important;\n  clip: auto;\n  height: auto;\n  width: auto;\n  overflow: visible;\n}\n\n// visually-hidden--focusable()\n//\n// Makes an element visually hidden by default, but visible when receiving\n// focus.\n//\n// Style guide: sass.mixins.visually-hidden--focusable\n@mixin visually-hidden--focusable {\n  @include visually-hidden;\n\n  &:active,\n  &:focus {\n    @include visually-hidden--off;\n  }\n}\n","// The relative path from the css directory to the sass directory.\n$image-url-path-to-source: '../sass' !default;\n// The relative path from the root sass directory to where your components usually lie.\n$image-url-subdirectory: 'components' !default;\n\n// image-url()\n//\n// If you include your images next to your component Sass files, you need to\n// specify a url() to point from the generated CSS to the Sass source like this:\n//\n// ```css\n// content: url(../sass/components/is-quite/long.svg);\n// ```\n//\n// With the `image-url()` function the path to all your components is assumed to\n// start with `../sass/components/` and you just need to give it the last, short\n// bit of the path in your Sass code like this:\n//\n// ```scss\n// content: image-url(is-quite/short.svg);\n// ```\n//\n// If you want to point at an image that is not in the components sub-directory\n// of your sass directory, you can override the default $subdirectory by\n// passing it in as the first parameter of `image-url()` like this:\n//\n// ```scss\n// content: image-url(base, grouping/blockquote.svg);\n// ```\n//\n// which would output `url(../sass/base/grouping/blockquote.svg)`.\n//\n// $subdirectory   = $image-url-subdirectory - Optional. The relative path from\n//                   the root of your Sass source to the sub-directory where\n//                   components usually lie.\n// $path           - Required. The path to the image relative to the\n//                   `$subdirectory`.\n// $path-to-source = $image-url-path-to-source - Optional. The relative path\n//                   from the css build directory to the sass source directory.\n//\n// Style guide: sass.mixins.image-url\n@function image-url($subdirectory, $path: null, $path-to-source: $image-url-path-to-source) {\n  // If only 1 parameter is given, its value is intended for the $path.\n  @if type-of($path) == 'null' {\n    $path: $subdirectory;\n    $subdirectory: $image-url-subdirectory;\n  }\n  @return url(unquote($path-to-source + '/' + $subdirectory + '/' + $path));\n}\n","// Do not print\n//\n// Removes an element from the print version of the web site.\n//\n// By importing these CSS rules in a file marked as media \"all\", we allow these\n// print rules to be aggregated with other stylesheets, for improved front-end\n// performance.\n//\n// Markup: print-none.twig\n//\n// Style guide: components.print-none\n\n.print-none,\n%print-none {\n  @media print {\n    display: none;\n  }\n}\n"],"names":[],"mappings":"AiCAA,iEAAiE;AsBc/D,MAAM,CAAC,KAAK;EAFd,AAAA,WAAW;EvDKX,AuDJA,MvDIM;EAEN,AuDNA,KvDMK;EACL,AuDPA,GvDOG;EACH,AuDRA,MvDQM,CuDRM;IAER,OAAO,EAAE,IAAI;GAEhB;;;AvDQD,MAAM,CAAC,KAAK;EACV,AAAA,IAAI,CAAC;IACH,SAAS,E0CSc,IAAI;G1CR5B;EAED,AAAA,IAAI;EACJ,AAAA,KAAK,CAAC;IACJ,gBAAgB,EyBTM,IAAI;GzBU3B;GAED,AAAA,AAAA,IAAC,CAAK,MAAM,AAAX,EAAa;IACZ,KAAK,EAAE,IAAI;GACZ;EAED,AAAA,KAAK;EACL,AAAA,QAAQ,CAAC;IACP,eAAe,EAAE,SAAS;GAC3B"}