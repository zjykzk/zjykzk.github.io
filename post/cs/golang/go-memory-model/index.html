<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>GO 内存模型 – zenk 随笔</title>
<meta name="description" content="GO内存模型，happens before 定义">
<meta name="created" content="2017-03-28T11:22:09&#43;0800">
<meta name="author" content="zenk"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
<meta name="MobileOptimized" content="width">
<meta name="HandheldFriendly" content="true">
<meta name="generator" content="Hugo 0.24.1" />

<link rel="stylesheet" href="/css/styles.css">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="canonical" href="http://zjykzk.github.io/post/cs/golang/go-memory-model/">
</head>

<body class="one-sidebar sidebar-second">
<div class="layout-center">
<header class="header" role="banner">
<h1 class="header__site-name">
<a href="http://zjykzk.github.io/" title="Home" class="header__site-link" rel="home"><span>zenk 随笔</span></a>
</h1>
<div class="header__region region region-header"></div>
</header>

<div class="layout-3col layout-swap">
<main class="layout-3col__left-content" role="main">
<h1 class="title title-submitted">GO 内存模型</h1>
<article class="section-post single-view">
<header>
<p class="submitted">
<span class="author">zenk</span> – <time class="modified-date" datetime="2017-03-28T11:22:09&#43;08:00">2017-03-28 11:22:09</time>
</p>

<div class="tags">
Tags:
<ul>
<li><a href="/tags/%E7%BC%96%E7%A8%8B">编程</a></li>
<li><a href="/tags/golang">golang</a></li>
</ul>
</div>

</header>
<div class="content">


<p>内存模型定义了一系列的条件，在这些条件下，多个goroutine对一个变量进行读写，保证一个goroutine读取到的值是是另外一个goroutine写入的某个值。</p>

<h2 id="happens-before">Happens Before</h2>

<p>编译器会对程序做优化，比如指令重排。在go语言中规定，在同一个goroutine里面，程序表达的顺序就是读写的顺序。但是，多个goroutine执行同样的代码时，就会出现读写顺序不一样的情况。例如，代码：</p>

<pre><code class="language-go">int a = 0;
int b = 1;
print(a);
print(b);
</code></pre>

<p>在编译器的优化下，代码的执行顺序有可能变成下面这样的情况：</p>

<pre><code class="language-go">int a = 0;
print(a);
int b = 1;
print(b);
</code></pre>

<p>但是，多个goroutine执行时，就无法保证打印*a*的时候，*b*的值一定是1.</p>

<p><strong>happens before</strong>定义了内存操作的顺序，它是一种偏序。<em>e1</em> happens before <em>e2</em>, <em>e2</em> happens after <em>e1</em> 。如果 <em>e1</em> 既不happens before <em>e2</em> 也不happens after <em>e2</em> ，那么 <em>e1</em> 和 <em>e2</em> 是并发执行的。它有传递的性质（自反性，对称性就不考虑了）。这个关系就决定了共享变量在某个上下文下面读写顺序，那么它的具体值变化也就确定了。</p>

<p><em>在一个goroutine中，happens before的顺序就是代码表达的顺序。</em></p>

<p>共享变量 <em>v</em> 的读操作 <em>r</em> ，能够读到是另一个对变量 <em>v</em> 写操作 <em>w</em> 写入的值的条件是：</p>

<ol>
<li><em>w</em> happens before <em>r</em><br /></li>
<li>没有其他的对变量 <em>v</em> 写操作happens before <em>r</em> 并且happens after <em>w</em><br />
<br /></li>
</ol>

<p>这两个条件并不能保证有一个与 <em>r&amp;w</em> 没有任何happens before关系的对共享变量 <em>v</em> 写操作 <em>w&rsquo;</em> 的存在，导致 <em>r</em> 读到的是 <em>w&rsquo;</em> 的结果。所以，保证 <em>r</em> 的结果是 <em>w</em> 的值的条件是：</p>

<ol>
<li><em>w</em> happens before <em>r</em><br /></li>
<li>在 <em>w</em> 和 <em>r</em> 之间没有任何写操作，也就是说其他的写操作要么happens before <em>w</em> ，要么happens after <em>r</em><br />
<br /></li>
</ol>

<p>在只有一个goroutine中1和2是等价的。 <em>r</em> 的结果一定是最近一次 <em>w</em> 的结果。<strong>如果多个goroutine访问共享变量，就会产生竞争，必须要通过同步机制建立happens before关系才能确定共享变量的值</strong>。</p>

<p>另外，1) 变量自动的初始化为其类型对应的0时，相当于是一个写操作，也会产生竞争；2) 对多个机器字进行读写的时候，哪个字先读写是不确定的。</p>

<h2 id="同步机制">同步机制</h2>

<h3 id="初始化">初始化</h3>

<p>程序的初始化是通过一个goroutine执行的，这个goroutine会生成一个新的goroutine，因此会有竞争存在。</p>

<ol>
<li>包 <em>p</em> 依赖 *q*，<em>q</em> 的 <em>init</em> 函数happens before包 <em>p</em> 的任何操作<br /></li>
<li>所有 <em>init</em> 函数执行结束happens before <em>main.main</em> 函数<br />
<br /></li>
</ol>

<h3 id="goroutine-创建">Goroutine 创建</h3>

<p><em>go</em> 语句happens before新创建的goroutine的运行。以下代码中，<strong><em>1</em></strong> happens before <strong><em>2</em></strong>，<strong><em>2</em></strong> happens before 函数<strong><em>f</em></strong>的执行，在将来的某个时刻所以打印 <code>hello, world</code>（可能是在hello函数返回之后）。</p>

<pre><code class="language-go">var a string

func f() {
	print(a)
}

func hello() {
	a = &quot;hello, world&quot; // 1
	go f()             // 2
}
</code></pre>

<h3 id="goroutine-销毁">Goroutine 销毁</h3>

<p>goroutine的退出跟其他的操作没有任何的happens before操作。以下代码无法保证<strong><em>print(a)</em></strong>的结果就是 <code>hello, world</code>。事实上，编译器完全有可能把 <em>go</em> 语句完全的删除掉。</p>

<pre><code class="language-go">var a string

func hello() {
	go func() { a = &quot;hello&quot; }()
	print(a)
}
</code></pre>

<h3 id="channel通信">Channel通信</h3>

<p>channel在golang里面是同步的一个重要手段。channel上面的每个发送操作，都唯一对应着一个channel上面的接受操作，显然发送／接受操作在不同的goroutine下面才需要讨论。</p>

<p><strong>在一个channel上面的发送操作的完成happens before想对应的接受操作的完成。</strong>以下代码中，按照本规则 <em>1</em> happens before <em>2</em> ，另外，因为 <em>2</em> 和 <em>3</em> 在同一个goroutine中执行， <em>2</em> happens before <em>3</em> ，所以能够打印出 <code>hello, world</code>。</p>

<pre><code class="language-go">var c = make(chan int, 10)
var a string

func f() {
	a = &quot;hello, world&quot;
	c &lt;- 0		// 1
}

func main() {
	go f()
	&lt;-c			// 2
	print(a)	 // 3
}
</code></pre>

<p><strong>channel的关闭操作happens before因为关闭channel读到的0值。</strong>上面例子中，用 <em>close( c)</em> 代替 <em>ch &lt;- 0</em> 同样能够保证 <em>1</em>  happens before <em>2</em>  。</p>

<p><strong>没有缓冲的channel上面的接受操作happens before发送操作。也就是说，发送操作只有在channel上面进行的接受操作结束以后才返回。</strong>以下代码中，根据本规则 <em>1</em> happens before <em>2</em> 。另外，因为 <em>2</em> 和 <em>3</em> 在同一个goroutine中执行， <em>2</em> happens before <em>3</em> ，所以能够打印出 <code>hello, world</code>。</p>

<pre><code>var c = make(chan int)
var a string

func f() {
	a = &quot;hello, world&quot;
	&lt;-c					// 1
}

func main() {
	go f()
	c &lt;- 0				// 2
	print(a)			// 3
}
</code></pre>

<p><strong>如果一个channel有 <em>C</em> 容量的缓冲，第 <em>k</em> 个接受操作happens before第 <em>k+C</em> 个发送操作。</strong>根据这个规则可以用带缓冲的channel来模拟信号量。以下程序就保证了，同时最多只有3个goroutine同时执行 <em>w</em> 函数。</p>

<pre><code class="language-go">var limit = make(chan int, 3)

func main() {
	for _, w := range work {
		go func(w func()) {
			limit &lt;- 1
			w()
			&lt;-limit
		}(w)
	}
	select{}
}
</code></pre>

<h3 id="locks">Locks</h3>

<p>包 <em>sync</em> 实现了两类锁分别是： <em>sync.Mutex</em> 和 <em>sync.RWMutex。</em></p>

<p><strong>给定类型为 <em>sync.Mutex</em> 或者是 <em>sync.RWMutex</em> 的变量 <em>l</em> ,以及满足 <em>n&lt;m</em> 条件的整数。调用 <em>n</em> 次 <em>l.Unlock()</em>  happens before 调用 <em>m</em> 次 <em>l.Lock()</em> （返回）。</strong>以下代码中，根据本规则 <em>1</em> happens before <em>2</em> ，另外，因为 <em>2</em> 和 <em>3</em> 在同一个goroutine中执行， <em>2</em> happens before <em>3</em> ，所以能够打印出 <code>hello, world</code>。</p>

<pre><code class="language-go">var l sync.Mutex
var a string

func f() {
	a = &quot;hello, world&quot;
	l.Unlock()		// 1
}

func main() {
	l.Lock()
	go f()
	l.Lock()		// 2
	print(a)		// 3
}
</code></pre>

<p><strong>对于 <em>sync.RWMutex</em> 类型的变量l，存在一个整数 <em>n</em> ， <em>l.RLock</em> 的调用happens after(返回)调用 <em>n</em> 次 <em>l.Unlock</em> ，与这个 <em>l.RLock</em> 想对应的 <em>l.RUnlock</em> happens before 第 <em>n+1</em> 的 <em>l.Lock</em> 。</strong></p>

<h3 id="once">Once</h3>

<p>Once提供了保证某段代码只执行一次的机制。对某个函数 <em>f</em> ， <em>once.Do(f)</em> 调用保证了 <em>f</em> 只被执行一次，如果有多个goroutine执行 <em>once.Do(f)</em> ，其中一个执行了，其他就等待直到f执行完毕。</p>

<p><strong>调用 <em>once.Do(f)</em> 中 <em>f</em> (返回)happens before 其他 <em>once.Do(f)</em> 调用完成。</strong></p>

<h2 id="总结">总结</h2>

<p>为了更有效率的执行程序，编译器，CPU都会一某种方式进行优化。当程序是并发执行的时候，内存的数据就变得无法根据程序代码判断内存中的值。内存模型的作用就是在程序的层面规定内存的操作顺序，以达到确定内存值的目的。而happens before是一个定义这个操作顺序的规范。</p>

</div>
</article>
</main>






<div class="layout-swap__top layout-3col__full">
<nav class="main-menu" role="navigation">
<h2 class="visually-hidden">Main menu</h2>
<ul class="navbar clearfix">
<li><a class="" href="/">Home</a></li>



  <li><a  class="active"href="/categories/cs">Computer</a>
  </li>

  <li><a  class=""href="/categories/test">test</a>
  </li>


<li><a class="" href="/post/about">About</a></li>
</ul>
</nav>
</div>

<aside class="layout-3col__right-sidebar" role="complementary">
<section>
<h4 class="menu"><a class="" href="/post/">Posts</a></h4>
<ul class="menu">
<li><a class="" href="/post/cs/golang/map/">map 内部实现</a></li>
<li><a class="" href="/post/cs/complement/">补码</a></li>
<li><a class="active" href="/post/cs/golang/go-memory-model/">GO 内存模型</a></li>
<li><a class="" href="/post/cs/str/">字符串</a></li>
<li><a class="" href="/post/cs/prometheus/">prometheus</a></li>
<li><a class="" href="/post/cs/ieee-754/">浮点数 IEEE 754</a></li>
<li><a class="" href="/post/cs/bug-op/">增加bug的编程实践</a></li>
<li><a class="" href="/post/cs/flume/">flume</a></li>
<li><a class="" href="/post/cs/friend-links/">价值博客</a></li>
<li><a class="" href="/post/about/">About</a></li>
</ul>
</section>
</aside>

</div>

<footer class="footer" role="contentinfo">

<p><span>© zenk 随笔</span></p>
<p>Powered by <a href="https://gohugo.io/">Hugo</a></p></footer>
</div>




</body>
</html>
