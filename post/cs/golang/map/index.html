<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>map 内部实现 – 老K随笔</title>
<meta name="description" content="golang 中map的实现细节">
<meta name="created" content="2017-06-15T19:13:25&#43;0800">
<meta name="author" content="zenk"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
<meta name="MobileOptimized" content="width">
<meta name="HandheldFriendly" content="true">
<meta name="generator" content="Hugo 0.25-DEV" />


<link href="/css/prism.css" rel="stylesheet" />

<link rel="stylesheet" href="/css/styles.css">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="canonical" href="http://zjykzk.github.io/post/cs/golang/map/">
</head>

<body class="one-sidebar sidebar-second">
<div class="layout-center">
<header class="header" role="banner">
<h1 class="header__site-name">
<a href="http://zjykzk.github.io/" title="Home" class="header__site-link" rel="home"><span>老K随笔</span></a>
</h1>
<div class="header__region region region-header"></div>
</header>

<div class="layout-3col layout-swap">
<main class="layout-3col__left-content" role="main">
<h1 class="title title-submitted">map 内部实现</h1>
<article class="section-post single-view">
<header>
<p class="submitted">
<span class="author">zenk</span> – <time class="modified-date" datetime="2017-06-15T19:13:25&#43;08:00">2017-06-15 19:13:25</time>
</p>

<div class="tags">
Tags:
<ul>
<li><a href="/tags/golang">golang</a></li>
<li><a href="/tags/%E7%BC%96%E7%A8%8B">编程</a></li>
</ul>
</div>

</header>
<div class="content">


<h1 id="类型">类型</h1>

<p>golang中的map是一个 <strong>指针</strong>。当执行语句 <code>make(map[string]string)</code> 的时候，其实是调用了 <code>makemap</code> 函数：</p>

<pre><code class="language-go">// file: runtime/hashmap.go:L222
func makemap(t *maptype, hint64, h *hmap, bucket unsafe.Pointer) *hmap
</code></pre>

<p>显然，<code>makemap</code> 返回的是指针。</p>

<h1 id="数据结构">数据结构</h1>

<h2 id="hashmap">hashmap</h2>

<pre><code class="language-go">// hash map
type hmap struct {
    count     int    // 元素的个数 == len()返回的值，必须放在第一个位置因为 len函数需要使用
    // map标记:
    // 1. key和value是否包指针
    // 2. 是否正在扩容
    // 3. 是否是同样大小的扩容
    // 4. 是否正在 `range`方式访问当前的buckets
    // 5. 是否有 `range`方式访问旧的bucket
    flags     uint8
    B         uint8  // log_2(B) == bucket数量
    noverflow uint16 // overflow bucket的数量，是个近似值
    hash0     uint32 // hash种子

    buckets    unsafe.Pointer // bucket slice指针，如果count == 0，这里的值为 nil
    oldbuckets unsafe.Pointer // bucket slice指针，仅当在扩容的时候不为nil
    nevacuate  uintptr        // 扩容时已经移到新的map中的bucket数量

    // 当key和value的类型不包含指针的时候，key和value就会做inline处理(怎么处理的)
    // 保证overflow的bucket活着，不被gc回收
    overflow *[2]*[]*bmap
}
</code></pre>

<h2 id="bucket">bucket</h2>

<p>每个bucket固定包含8个key和value。实现上面是一个固定的大小连续内存块，分成四部分：</p>

<ol>
<li>每个条目的状态<br /></li>
<li>8个key值<br /></li>
<li>8个value值<br /></li>
<li>指向下个bucket的指针<br />
<br /></li>
</ol>

<p>数据结构定义如下：</p>

<pre><code class="language-go">// bucket
type bmap struct {
        // 每个条目的状态，tophash[0]表示当前bucket中的条目是否已经完全移到新的bucket中去了
        tophash [bucketCnt]uint8
        // keys
        // values
        // Followed by an overflow pointer.
}
</code></pre>

<h3 id="条目状态">条目状态</h3>

<p>. <code>0</code> 空，可以被使用</p>

<p>. <code>1</code> 空，bucket中的内容已经被移到了新的bucket中</p>

<p>. <code>2</code> 该条目已经被移到了新的bucket，该bucket的位置在处在前半部分</p>

<p>. <code>3</code> 该条目已经被移到了新的bucket，该bucket的位置在处在后半部分</p>

<p>. 其他大于等于<code>4</code> 的值，来自key的hash值的最高8位，如果高8位值小于4，则加4</p>

<h4 id="第一个条目状态">第一个条目状态</h4>

<p>bucket的第一个条目<code>tophash[0]</code> 用来标识bucket中的条目是否已经全部被移到了新的bucket中去了， <code>1-3</code> 表示已经移动完。</p>

<h3 id="内存布局">内存布局</h3>

<pre><code>   ^   +-----------------+ -.
   |   |       bucket0   |  |------&gt; +------------+
   |   +-----------------+ -'        | tophash 0  |
   |   |       bucket1   |           +------------+
   |   +-----------------+           | tophash 1  |
2^h.B  |      .......    |           +------------+
   |   +-----------------+           | .........  |
   |   | bucket2^h.B - 2 |           +------------+
   |   +-----------------+           | tophash 6  |
   |   | bucket2^h.B - 1 |           +------------+
   v   +-----------------+           | tophash 7  |
                                     +------------+
                                     |   key 0    |
                                     +------------+
                                     |   key 1    |
                                     +------------+
                                     |   .....    |
                                     +------------+
                                     |   key 6    |
                                     +------------+
                                     |   key 7    |
                                     +------------+
                                     |  value 0   |
                                     +------------+
                                     |  value 1   |
                                     +------------+
                                     |  .......   |
                                     +------------+
                                     |  value 6   |
                                     +------------+
                                     |  value 7   |
                                     +------------+ -.
                                     |overflow_ptr|  |-----&gt; new bucket address
                                     +------------+ -'
</code></pre>

<p>选择这样的布局的好处：由于对齐的原因，<em>key0/value0/key1/value1&hellip;</em> 这样的形式可能需要更多的补齐空间，比如 <code>map[int64]int8</code> ，1字节的value后面需要补齐7个字节才能保证下一个key是 <code>int64</code> 对齐的。</p>

<h2 id="装载因子">装载因子</h2>

<p>装载因子决定hashmap的资源使用率以及性能高低，在实现hashmap时，考虑四个方面：</p>

<ol>
<li>%overflow：拥有overflow的bucket的百分比<br /></li>
<li>bytes/entry: 每个key/value的额外开销<br /></li>
<li>hitprobe: 查找存在的key时需要检查的条目数量<br /></li>
<li>missprobe: 查找不存在的key是需要检查的条目数量<br />
<br /></li>
</ol>

<p>结果是选择触发扩容时的值，其测试数据如下：</p>

<table>
<thead>
<tr>
<th align="center">装载因子</th>
<th align="center">%overflow</th>
<th align="center">bytes/entry</th>
<th align="center">hitprobe</th>
<th align="center">missprobe</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">6.5</td>
<td align="center">20.90</td>
<td align="center">10.79</td>
<td align="center">4.25</td>
<td align="center">6.5</td>
</tr>
</tbody>
</table>

<h1 id="扩容">扩容</h1>

<p>当进行添加元素的操作时，如果超过装载因子，或者overflow的bucket数量超出阈值，就会触发扩容的操作。如果是因为overflow的bucket数量过多引起的，hashmap的容量不会扩大，不然就扩大为原来的大小的两倍。</p>

<p>在实现扩容的时候，会先为需要的bucket分配新内存，然后把旧的bucket保存起来，再把旧的内容移到新的bucket中去。</p>

<h1 id="线程安全">线程安全</h1>

<p>map是线程不安全的。但是在实现中有很多关于并发访问的代码，比如</p>

<ol>
<li>在迭代的时候会做是否正在扩容<br /></li>
<li>添加数据的时候是否有其他数据正在写，有的话会panic<br />
<br /></li>
</ol>

<p>既然不是线程安全，为啥要做这样的检查，不检查的话可以简化代码提高性能。检查的好处就是告知提醒用户并发访问了map，但是这个检查也不是百分之一百的检测到所有的并发访问。</p>

<h1 id="键值nan">键值NaN</h1>

<p><code>NaN</code> 的hash值是随机(<a href="https://research.swtch.com/randhash">原因</a>)，也就是说每次计算hash值都有可能是不一样的。这个跟python/java等其他语言有比较大的差别。</p>

<p>正是因为这样有了以下几个有趣的事情：</p>

<ol>
<li>当 <code>NaN</code> 作为key的时候，为了保持hash值的不变性，利用 <code>tophash</code> 的最低位来判断是放在扩容以后bucket的上半部份还是下半部分<br /></li>
<li>用 <code>NaN</code> 做key取数据时永远也取不到，用 <code>for</code> 迭代map是唯一一种访问 key为<code>NaN</code> 的内容的方式<br />
<br /></li>
</ol>

<h1 id="迭代">迭代</h1>

<p><code>for</code> 语句迭代map，在会调用函数 <code>mapiterinit</code> 做初始化工作：</p>

<ol>
<li>随机挑选一个起始位置开始迭代：a. bucket随机选一个，b. bucket中的起始条目也是随机的<br /></li>
<li>初始化overflow，目的是为了防止那些内联的数据被gc，导致迭代失败<br />
<br /></li>
</ol>

<p>每次获取一个元素的时候调用函数<code>mapiternext</code></p>

</div>
</article>
</main>






<div class="layout-swap__top layout-3col__full">
<nav class="main-menu" role="navigation">
<h2 class="visually-hidden">Main menu</h2>
<ul class="navbar clearfix">
<li><a class="" href="/">Home</a></li>



  <li><a  class="active"href="/categories/cs">Computer</a>
  </li>

  <li><a  class=""href="/categories/test">test</a>
  </li>


<li><a class="" href="/post/about">About</a></li>
</ul>
</nav>
</div>

<aside class="layout-3col__right-sidebar" role="complementary">
<section>
<h4 class="menu"><a class="" href="/post/">Posts</a></h4>
<ul class="menu">
<li><a class="active" href="/post/cs/golang/map/">map 内部实现</a></li>
<li><a class="" href="/post/cs/complement/">补码</a></li>
<li><a class="" href="/post/cs/golang/go-memory-model/">GO 内存模型</a></li>
<li><a class="" href="/post/cs/str/">字符串</a></li>
<li><a class="" href="/post/cs/prometheus/">prometheus</a></li>
<li><a class="" href="/post/cs/ieee-754/">浮点数 IEEE 754</a></li>
<li><a class="" href="/post/cs/bug-op/">增加bug的编程实践</a></li>
<li><a class="" href="/post/cs/flume/">flume</a></li>
<li><a class="" href="/post/cs/friend-links/">价值博客</a></li>
<li><a class="" href="/post/about/">About</a></li>
</ul>
</section>
</aside>

</div>

<footer class="footer" role="contentinfo">

<p><span>© 老K随笔</span></p>
<p>Powered by <a href="https://gohugo.io/">Hugo</a></p></footer>
</div>




<script src="/js/prism.js"></script>


</body>
</html>
