<!DOCTYPE html>
<html class="nojs" lang="zh" dir="ltr">
<head>
<meta charset="utf-8">
<title>map 内部实现 – 老K随笔</title>
<meta name="description" content="golang 中map的实现细节，它是一个典型的hashmap。">
<meta name="created" content="2017-06-15T19:13:25&#43;0800">
<meta name="modified" content="2017-06-15T19:13:25&#43;0800">
<meta name="author" content="zenk">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=2.0, user-scalable=yes">
<meta name="MobileOptimized" content="width">
<meta name="HandheldFriendly" content="true">
<meta name="generator" content="Hugo 0.48-DEV" />


<link href="/css/prism.css" rel="stylesheet" />

<link rel="stylesheet" href="/css/styles.css">
<link rel="canonical" href="http://zjykzk.github.io/post/cs/golang/map/">
<link rel="apple-touch-icon" href="/apple-touch-icon.png">
<link rel="preload" as="style" href="/css/styles.css">
<link rel="stylesheet" href="/css/styles.css">
<link rel="stylesheet" href="/css/print.css" media="print">
<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "headline": "map 内部实现",
    "datePublished": "2017-06-15T19:13:25+08:00",
    "dateModified": "2017-06-15T19:13:25+08:00",
    "url" : "http://zjykzk.github.io/post/cs/golang/map/",
    "description": "golang 中map的实现细节，它是一个典型的hashmap。",
    "keywords": ["golang","program"],
    "author": {
      "@type": "Person",
      "name": "zenk"
    },
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id": "http://zjykzk.github.io/"
    },
    "publisher": {
      "@type": "Organization",
      "name": "老K随笔",
      "url": "http://zjykzk.github.io/",
    }
  }
</script>

</head>

<body>
<div class="page layout__page">
<header class="header layout__header" role="banner">

<h1 class="header__site-name">
<a href="http://zjykzk.github.io/" title="Home" class="header__site-link" rel="home"><span>老K随笔</span></a>
</h1>
<div class="region header__region"></div>
</header>






<div class="layout-swap__top layout-3col__full">
<nav class="main-menu layout__navigation" role="navigation">
<h2 class="visually-hidden">主菜单</h2>
<ul class="navbar">
<li><a class="" href="/">首页</a></li>



  <li><a  class=""href="/categories/buddhism">佛法</a>
  </li>

  <li><a  class="active"href="/categories/cs">计算机</a>
  </li>


<li><a class="" href="/post/about">关于</a></li>
</ul>
</nav>


<main class="main layout__main" role="main">
<h1 class="title title-submitted">map 内部实现</h1>
<article class="section-post single-view">
<header>
<p class="submitted">
<span class="author">zenk</span> – <time class="modified-date" datetime="2017-06-15T19:13:25&#43;08:00">2017-06-15 19:13:25</time>
</p>
<div class="tags">
Tags:
<ul>
<li><a href="/tags/golang">golang</a></li>
<li><a href="/tags/program">编程</a></li>
</ul>
</div>
</header>
<div class="content">


<h1 id="类型">类型</h1>

<p>golang中的map是一个 <strong>指针</strong>。当执行语句 <code>make(map[string]string)</code> 的时候，其实是调用了 <code>makemap</code> 函数：</p>

<pre><code class="language-go">// file: runtime/hashmap.go:L222
func makemap(t *maptype, hint64, h *hmap, bucket unsafe.Pointer) *hmap
</code></pre>

<p>显然，<code>makemap</code> 返回的是指针。</p>

<h1 id="数据结构">数据结构</h1>

<h2 id="hashmap">hashmap</h2>

<pre><code class="language-go">// hash map
type hmap struct {
    // 元素的个数 == len()返回的值，必须放在第一个位置因为 len函数需要使用
    count     int

    // map标记:
    // 1. key和value是否包指针
    // 2. 是否正在扩容
    // 3. 是否是同样大小的扩容
    // 4. 是否正在 `range`方式访问当前的buckets
    // 5. 是否有 `range`方式访问旧的bucket
    flags     uint8
    B         uint8  // log_2(B) == bucket数量
    noverflow uint16 // overflow bucket的数量，是个近似值
    hash0     uint32 // hash种子

    buckets    unsafe.Pointer // bucket slice指针，如果count == 0，这里的值为 nil
    oldbuckets unsafe.Pointer // bucket slice指针，仅当在扩容的时候不为nil
    nevacuate  uintptr        // 扩容时已经移到新的map中的bucket数量

    // 当key和value的类型不包含指针的时候，key和value就会做inline处理(怎么处理的)
    // 保证overflow的bucket活着，不被gc回收
    overflow *[2]*[]*bmap
}
</code></pre>

<h2 id="bucket">bucket</h2>

<p>每个bucket固定包含8个key和value。实现上面是一个固定的大小连续内存块，分成四部分：</p>

<ol>
<li>每个条目的状态<br /></li>
<li>8个key值<br /></li>
<li>8个value值<br /></li>
<li>指向下个bucket的指针<br />
<br /></li>
</ol>

<p>数据结构定义如下：</p>

<pre><code class="language-go">// bucket
type bmap struct {
        // 每个条目的状态，tophash[0]表示当前bucket中的条目是否已经完全移到新的bucket中去了
        tophash [bucketCnt]uint8
        // keys
        // values
        // Followed by an overflow pointer.
}
</code></pre>

<h3 id="条目状态">条目状态</h3>

<p>. <code>0</code> 空，可以被使用</p>

<p>. <code>1</code> 空，bucket中的内容已经被移到了新的bucket中</p>

<p>. <code>2</code> 该条目已经被移到了新的bucket，该bucket的位置在处在前半部分</p>

<p>. <code>3</code> 该条目已经被移到了新的bucket，该bucket的位置在处在后半部分</p>

<p>. 其他大于等于<code>4</code> 的值，来自key的hash值的最高8位，如果高8位值小于4，则加4</p>

<h4 id="第一个条目状态">第一个条目状态</h4>

<p>bucket的第一个条目<code>tophash[0]</code> 用来标识bucket中的条目是否已经全部被移到了新的bucket中去了， <code>1-3</code> 表示已经移动完。</p>

<h3 id="内存布局">内存布局</h3>

<pre><code>   ----+-----------------+ -.
   ^   |     bucket0     |  |------&gt; +------------+
   |   +-----------------+ -'        | tophash0-7 |
2^h.B  |     .......     |           +------------+
   |   +-----------------+           |   key0-7   |
   v   | bucket2^h.B - 1 |           +------------+
   ----+-----------------+           |  value0-7  |
                                     +------------+ -.
                                     |overflow_ptr|  |-----&gt; new bucket address
                                     +------------+ -'
</code></pre>

<p>选择这样的布局的好处：由于对齐的原因，<em>key0/value0/key1/value1&hellip;</em> 这样的形式可能需要更多的补齐空间，比如 <code>map[int64]int8</code> ，1字节的value后面需要补齐7个字节才能保证下一个key是 <code>int64</code> 对齐的。</p>

<h2 id="装载因子">装载因子</h2>

<p>装载因子决定map的资源使用率以及性能高低，在实现map时，考虑四个方面：</p>

<ol>
<li>%overflow：拥有overflow的bucket的百分比<br /></li>
<li>bytes/entry: 每个key/value的额外开销<br /></li>
<li>hitprobe: 查找存在的key时需要检查的条目数量<br /></li>
<li>missprobe: 查找不存在的key是需要检查的条目数量<br />
<br /></li>
</ol>

<p>其测试数据如下：</p>

<table>
<thead>
<tr>
<th align="center">装载因子</th>
<th align="center">%overflow</th>
<th align="center">bytes/entry</th>
<th align="center">hitprobe</th>
<th align="center">missprobe</th>
</tr>
</thead>

<tbody>
<tr>
<td align="center">6.5</td>
<td align="center">20.90</td>
<td align="center">10.79</td>
<td align="center">4.25</td>
<td align="center">6.5</td>
</tr>
</tbody>
</table>

<h1 id="hash函数">hash函数</h1>

<p>map中的key对应着一个hash函数，用于定位bucket。在golang的hash函数是固定的，用户无法修改。golang中的预定义基本类型，像 <code>int32/int64/string/interface</code> 等等都有一个hash函数与之对应，代码在runtime/alg.go中。对于struct/数组/slice，如果它每个字段或者元素都是有hash函数，那么该类型就有hash函数，hash值由每个字段的hash值来定义，代码在reflect/type.go函数<code>StructOf</code>中。</p>

<p>注：<code>map</code>是不能作为key的。</p>

<h1 id="扩容">扩容</h1>

<p>当进行添加元素的操作时，如果超过装载因子，或者overflow的bucket数量超出阈值，就会触发扩容的操作。如果是因为overflow的bucket数量过多引起的，map的容量不会扩大，不然就扩大为原来的大小的两倍。</p>

<p>在实现扩容的时候，会先为需要的bucket分配新内存，然后把旧的bucket保存起来，再把旧的内容移到新的bucket中去。</p>

<h1 id="线程安全">线程安全</h1>

<p>map是线程不安全的。但是在实现中有很多关于并发访问的代码，比如</p>

<ol>
<li>在迭代的时候会做是否正在扩容<br /></li>
<li>添加数据的时候是否有其他数据正在写，有的话会panic<br />
<br /></li>
</ol>

<p>既然不是线程安全，为啥要做这样的检查，不检查的话可以简化代码提高性能。检查的好处就是告知提醒用户并发访问了map，但是这个检查也不是百分之一百的检测到所有的并发访问。</p>

<h1 id="键值nan">键值NaN</h1>

<p><code>NaN</code> 的hash值是随机(<a href="https://research.swtch.com/randhash">原因</a>)，也就是说每次计算hash值都有可能是不一样的。这个跟python/java等其他语言有比较大的差别。</p>

<p>正是因为这样有了以下几个有趣的事情：</p>

<ol>
<li>当 <code>NaN</code> 作为key的时候，为了保持hash值的不变性，利用 <code>tophash</code> 的最低位来判断是放在扩容以后bucket的上半部份还是下半部分<br /></li>
<li>用 <code>NaN</code> 做key取数据时永远也取不到，用 <code>for</code> 迭代map是唯一一种访问 key为<code>NaN</code> 的内容的方式<br />
<br /></li>
</ol>

<h1 id="迭代">迭代</h1>

<p><code>for</code> 语句迭代map，在会调用函数 <code>mapiterinit</code> 做初始化工作：</p>

<ol>
<li>随机挑选一个起始位置开始迭代：a. bucket随机选一个，b. bucket中的起始条目也是随机的<br /></li>
<li>初始化overflow，目的是为了防止那些内联的数据被gc，导致迭代失败<br />
<br /></li>
</ol>

<p>每次获取一个元素的时候调用函数<code>mapiternext</code></p>


</div>
</article>
</main>




<footer class="footer layout__footer" role="contentinfo">
<p><span>© 老K随笔</span></p>

<p>Powered by <a href="https://gohugo.io/">Hugo</a> and the <a href="https://github.com/frjo/hugo-theme-zen">Zen theme</a>.</p>
</footer>

</div>




<script src="/js/prism.js"></script>


</body>
</html>
