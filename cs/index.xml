<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Cs on zenk 随笔</title>
    <link>http://zjykzk.github.io/cs/</link>
    <description>Recent content in Cs on zenk 随笔</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <managingEditor>zhangkai.zju@gmail.com (zenk)</managingEditor>
    <webMaster>zhangkai.zju@gmail.com (zenk)</webMaster>
    <copyright>(c) 2017 zenk.</copyright>
    <lastBuildDate>Tue, 28 Mar 2017 11:22:09 +0800</lastBuildDate>
    <atom:link href="http://zjykzk.github.io/cs/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title></title>
      <link>http://zjykzk.github.io/cs/</link>
      <pubDate>Tue, 28 Mar 2017 11:22:09 +0800</pubDate>
      <author>zhangkai.zju@gmail.com (zenk)</author>
      <guid>http://zjykzk.github.io/cs/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Golang</title>
      <link>http://zjykzk.github.io/cs/golang/</link>
      <pubDate>Tue, 28 Mar 2017 11:22:09 +0800</pubDate>
      <author>zhangkai.zju@gmail.com (zenk)</author>
      <guid>http://zjykzk.github.io/cs/golang/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
fore&#34;&gt;Happens Before&lt;/h2&gt;

&lt;p&gt;编译器会对程序做优化，比如指令重排。在go语言中规定，在同一个goroutine里面，程序表达的顺序就是读写的顺序。但是，多个goroutine执行同样的代码时，就会出现读写顺序不一样的情况。例如，代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;int a = 0;
int b = 1;
print(a);
print(b);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在编译器的优化下，代码的执行顺序有可能变成下面这样的情况：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;int a = 0;
print(a);
int b = 1;
print(b);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是，多个goroutine执行时，就无法保证打印*a*的时候，*b*的值一定是1.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;happens before&lt;/strong&gt;定义了内存操作的顺序，它是一种偏序。&lt;em&gt;e1&lt;/em&gt; happens before &lt;em&gt;e2&lt;/em&gt;, &lt;em&gt;e2&lt;/em&gt; happens after &lt;em&gt;e1&lt;/em&gt; 。如果 &lt;em&gt;e1&lt;/em&gt; 既不happens before &lt;em&gt;e2&lt;/em&gt; 也不happens after &lt;em&gt;e2&lt;/em&gt; ，那么 &lt;em&gt;e1&lt;/em&gt; 和 *e2*是并发执行的。它有传递的性质（自反性，对称性就不考虑了）。这个关系就决定了共享变量在某个上下文下面读写顺序，那么它的具体值变化也就确定了。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;在一个goroutine中，happens before的顺序就是代码表达的顺序。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;共享变量 &lt;em&gt;v&lt;/em&gt; 的读操作 &lt;em&gt;r&lt;/em&gt; ，能够读到是另一个对变量 &lt;em&gt;v&lt;/em&gt; 写操作 &lt;em&gt;w&lt;/em&gt; 写入的值的条件是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;w&lt;/em&gt; happens before &lt;em&gt;r&lt;/em&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;没有其他的对变量 &lt;em&gt;v&lt;/em&gt; 写操作happens before &lt;em&gt;r&lt;/em&gt; 并且happens after &lt;em&gt;w&lt;/em&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这两个条件并不能保证有一个与 &lt;em&gt;r&amp;amp;w&lt;/em&gt; 没有任何happens before关系的对共享变量 &lt;em&gt;v&lt;/em&gt; 写操作 &lt;em&gt;w&amp;rsquo;&lt;/em&gt; 的存在，导致 &lt;em&gt;r&lt;/em&gt; 读到的是 &lt;em&gt;w&amp;rsquo;&lt;/em&gt; 的结果。所以，保证 &lt;em&gt;r&lt;/em&gt; 的结果是 &lt;em&gt;w&lt;/em&gt; 的值的条件是：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;em&gt;w&lt;/em&gt; happens before &lt;em&gt;r&lt;/em&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;在 &lt;em&gt;w&lt;/em&gt; 和 &lt;em&gt;r&lt;/em&gt; 之间没有任何写操作，也就是说其他的写操作要么happens before &lt;em&gt;w&lt;/em&gt; ，要么happens after &lt;em&gt;r&lt;/em&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在只有一个goroutine中1和2是等价的。 &lt;em&gt;r&lt;/em&gt; 的结果一定是最近一次 &lt;em&gt;w&lt;/em&gt; 的结果。&lt;strong&gt;如果多个goroutine访问共享变量，就会产生竞争，必须要通过同步机制建立happens before关系才能确定共享变量的值&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;另外，1) 变量自动的初始化为其类型对应的0时，相当于是一个写操作，也会产生竞争；2) 对多个机器字进行读写的时候，哪个字先读写是不确定的。&lt;/p&gt;

&lt;h2 id=&#34;同步机制&#34;&gt;同步机制&lt;/h2&gt;

&lt;h3 id=&#34;初始化&#34;&gt;初始化&lt;/h3&gt;

&lt;p&gt;程序的初始化是通过一个goroutine执行的，这个goroutine会生成一个新的goroutine，因此会有竞争存在。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;包 &lt;em&gt;p&lt;/em&gt; 依赖 &lt;em&gt;q&lt;/em&gt; ， &lt;em&gt;q&lt;/em&gt; 的 &lt;em&gt;init&lt;/em&gt; 函数happens before包 &lt;em&gt;p&lt;/em&gt; 的任何操作&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;所有 &lt;em&gt;init&lt;/em&gt; 函数执行结束happens before *main.main*函数&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;goroutine-创建&#34;&gt;Goroutine 创建&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;go&lt;/em&gt; 语句happens before新创建的goroutine的运行。以下代码中，&lt;strong&gt;&lt;em&gt;1&lt;/em&gt;&lt;/strong&gt; happens before &lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt;，&lt;strong&gt;&lt;em&gt;2&lt;/em&gt;&lt;/strong&gt; happens before 函数&lt;strong&gt;&lt;em&gt;f&lt;/em&gt;&lt;/strong&gt;的执行，在将来的某个时刻所以打印&lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;（可能是在hello函数返回之后）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a string

func f() {
	print(a)
}

func hello() {
	a = &amp;quot;hello, world&amp;quot; // 1
	go f()			  // 2
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;goroutine-销毁&#34;&gt;Goroutine 销毁&lt;/h3&gt;

&lt;p&gt;goroutine的退出跟其他的操作没有任何的happens before操作。以下代码无法保证&lt;strong&gt;&lt;em&gt;print(a)&lt;/em&gt;&lt;/strong&gt;的结果就是&lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;。事实上，编译器完全有可能把 &lt;em&gt;go&lt;/em&gt; 语句完全的删除掉。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var a string

func hello() {
	go func() { a = &amp;quot;hello&amp;quot; }()
	print(a)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;channel通信&#34;&gt;Channel通信&lt;/h3&gt;

&lt;p&gt;channel在golang里面是同步的一个重要手段。channel上面的每个发送操作，都唯一对应着一个channel上面的接受操作，显然发送／接受操作在不同的goroutine下面才需要讨论。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;在一个channel上面的发送操作的完成happens before想对应的接受操作的完成。&lt;/strong&gt;以下代码中，按照本规则 &lt;em&gt;1&lt;/em&gt; happens before &lt;em&gt;2&lt;/em&gt; ，另外，因为 &lt;em&gt;2&lt;/em&gt; 和 &lt;em&gt;3&lt;/em&gt; 在同一个goroutine中执行， &lt;em&gt;2&lt;/em&gt; happens before &lt;em&gt;3&lt;/em&gt; ，所以能够打印出&lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var c = make(chan int, 10)
var a string

func f() {
	a = &amp;quot;hello, world&amp;quot;
	c &amp;lt;- 0		// 1
}

func main() {
	go f()
	&amp;lt;-c			// 2
	print(a)	 // 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;channel的关闭操作happens before因为关闭channel读到的0值。&lt;/strong&gt;上面例子中，用 &lt;em&gt;close( c)&lt;/em&gt; 代替 &lt;em&gt;ch &amp;lt;- 0&lt;/em&gt; 同样能够保证 &lt;em&gt;1&lt;/em&gt;  happens before &lt;em&gt;2&lt;/em&gt;  。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;没有缓冲的channel上面的接受操作happens before发送操作。也就是说，发送操作只有在channel上面进行的接受操作结束以后才返回。&lt;/strong&gt;以下代码中，根据本规则 &lt;em&gt;1&lt;/em&gt; happens before &lt;em&gt;2&lt;/em&gt; ，另外，因为 &lt;em&gt;2&lt;/em&gt; 和 &lt;em&gt;3&lt;/em&gt; 在同一个goroutine中执行， &lt;em&gt;2&lt;/em&gt; happens before &lt;em&gt;3&lt;/em&gt; ，所以能够打印出&lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var c = make(chan int)
var a string

func f() {
	a = &amp;quot;hello, world&amp;quot;
	&amp;lt;-c					// 1
}

func main() {
	go f()
	c &amp;lt;- 0				// 2
	print(a)			// 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;如果一个channel有 &lt;em&gt;C&lt;/em&gt; 容量的缓冲，第 &lt;em&gt;k&lt;/em&gt; 个接受操作happens before第 &lt;em&gt;k+C&lt;/em&gt; 个发送操作。&lt;/strong&gt;根据这个规则可以用带缓冲的channel来模拟信号量。以下程序就保证了，同时最多只有3个goroutine同时执行 &lt;em&gt;w&lt;/em&gt; 函数。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var limit = make(chan int, 3)

func main() {
	for _, w := range work {
		go func(w func()) {
			limit &amp;lt;- 1
			w()
			&amp;lt;-limit
		}(w)
	}
	select{}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;locks&#34;&gt;Locks&lt;/h3&gt;

&lt;p&gt;包 &lt;em&gt;sync&lt;/em&gt; 实现了两类锁分别是： &lt;em&gt;sync.Mutex&lt;/em&gt; 和 &lt;em&gt;sync.RWMutex。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;给定类型为 &lt;em&gt;sync.Mutex&lt;/em&gt; 或者是 &lt;em&gt;sync.RWMutex&lt;/em&gt; 的变量 &lt;em&gt;l&lt;/em&gt; ,以及满足 &lt;em&gt;n&amp;lt;m&lt;/em&gt; 条件的整数。调用 &lt;em&gt;n&lt;/em&gt; 次 &lt;em&gt;l.Unlock()&lt;/em&gt;  happens before 调用 &lt;em&gt;m&lt;/em&gt; 次 &lt;em&gt;l.Lock()&lt;/em&gt; （返回）。&lt;/strong&gt;以下代码中，根据本规则 &lt;em&gt;1&lt;/em&gt; happens before &lt;em&gt;2&lt;/em&gt; ，另外，因为 &lt;em&gt;2&lt;/em&gt; 和 &lt;em&gt;3&lt;/em&gt; 在同一个goroutine中执行， &lt;em&gt;2&lt;/em&gt; happens before &lt;em&gt;3&lt;/em&gt; ，所以能够打印出&lt;code&gt;&amp;quot;hello, world&amp;quot;&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-go&#34;&gt;var l sync.Mutex
var a string

func f() {
	a = &amp;quot;hello, world&amp;quot;
	l.Unlock()		// 1
}

func main() {
	l.Lock()
	go f()
	l.Lock()		// 2
	print(a)		// 3
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;对于 &lt;em&gt;sync.RWMutex&lt;/em&gt; 类型的变量l，存在一个整数 &lt;em&gt;n&lt;/em&gt; ， &lt;em&gt;l.RLock&lt;/em&gt; 的调用happens after(返回)调用 &lt;em&gt;n&lt;/em&gt; 次 &lt;em&gt;l.Unlock&lt;/em&gt; ，与这个 &lt;em&gt;l.RLock&lt;/em&gt; 想对应的 &lt;em&gt;l.RUnlock&lt;/em&gt; happens before 第 &lt;em&gt;n+1&lt;/em&gt; 的 &lt;em&gt;l.Lock&lt;/em&gt; 。&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;once&#34;&gt;Once&lt;/h3&gt;

&lt;p&gt;Once提供了保证某段代码只执行一次的机制。对某个函数 &lt;em&gt;f&lt;/em&gt; ， &lt;em&gt;once.Do(f)&lt;/em&gt; 调用保证了 &lt;em&gt;f&lt;/em&gt; 只被执行一次，如果有多个goroutine执行 &lt;em&gt;once.Do(f)&lt;/em&gt; ，其中一个执行了，其他就等待直到f执行完毕。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;调用 &lt;em&gt;once.Do(f)&lt;/em&gt; 中 &lt;em&gt;f&lt;/em&gt; (返回)happens before 其他 &lt;em&gt;once.Do(f)&lt;/em&gt; 调用完成。&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;为了更有效率的执行程序，编译器，CPU都会一某种方式进行优化。当程序是并发执行的时候，内存的数据就变得无法根据程序代码判断内存中的值。内存模型的作用就是在程序的层面规定内存的操作顺序，以达到确定内存值的目的。而happens before是一个定义这个操作顺序的规范。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>增加bug的编程实践</title>
      <link>http://zjykzk.github.io/post/cs/bug-op/</link>
      <pubDate>Sat, 04 Jun 2016 11:12:13 +0800</pubDate>
      <author>zhangkai.zju@gmail.com (zenk)</author>
      <guid>http://zjykzk.github.io/post/cs/bug-op/</guid>
      <description>

&lt;p&gt;最近一个任务，时间比较仓促，需要在老系统上面修改添加功能，结果出现不少bug。小结一下工作中引入bug的一些实践。&lt;/p&gt;

&lt;h2 id=&#34;思路不清晰&#34;&gt;思路不清晰&lt;/h2&gt;

&lt;p&gt;思路没有完全确定情况下写代码。造成不确定的情况有多方面：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 求快，把相似的需求当做一样的需求
2. 缺少设计，大体明白实现方案，就开始编码
3. 知识不充分，集中在前端的css、布局
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;怎么办？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;快是可以做到，心里不要慌就是。&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1. 需求分析到位
2. 仔细查看现有的代码
3. 遗留代码多问老员工
4. 放下别人对你问代码时的负面情绪
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;破窗原理&#34;&gt;破窗原理&lt;/h2&gt;

&lt;p&gt;在一个代码质量差的项目里面，就很容易被一种“别人也是这样，我也就这样得了”，尤其是在你不熟悉代码的情况下。&lt;strong&gt;短期内，代码是写给自己的，维护的人是自己，长期内是给别人的，都自己好就是对别人好，还有就是执行力&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
